	.title	DESCPU
	.enabl	LC,AMA	; local labels, absolute addr mode (important)
	.list	MEB	; enable macro-extensions binary listing
	.asect
.=0	; from address 0 (!)
	
; custom linker, use macroses with caution
; .ENABL AMA is important for absolute addrs with macro11.exe (!)
; 
; preprocessor:
; @include filename.ext - includes file
; .ppexe VAR - macro
;	mov	VAR, R5
;	call	PPUExecute

@include inc_common.mac
@include inc_cpu_header.mac

	mtps	#600			; PSW - HP**TNZVC (010000000)
	mov	#1000, SP		; stack is 500..776(8)

	; disable serial adapters interrupts
	;bic	#100, @#176560		; network, input
	;bic	#100, @#176564		; network, output
	bic	#100, @#176570		; rs-232, input
	bic	#100, @#176574		; rs-232, output
	; trap register, disable interrupts
	; emustudio is using it - so it's commented here
	;mov	#0, @#176644

	; clear CPU upper RAM
	mov	#END, R0
	mov	#<160000-END/2>, R3
	clr	(R0)+
	sob	R3, .-2

	; ask for 'ppu phase 3'
	mov	#30, PPUState
        ; wait for ackn of phase 3
	cmp	#03, PPUState
	bne	.-6

	mov	#VSync, @#100		; vsync interrupt
	mtps	#0


; //////////////////////////////////////////////////////////////////////////////
; // MAIN
; //////////////////////////////////////////////////////////////////////////////

; main CPU cycle
MainCycle:
	call	VSyncWait		; vsync wait cycle
	call	CheckStop		; STOP key - reset game
	call	CheckColors		; K1 key - RGB/GRB
	; key UST - pause
	tst	KeyUst
	beq	10$
	clr	KeyUst
	comb	Pause
10$:	tstb	Pause
	bne	MainCycle
	; run procedures
	mov	CurrentMode, R0
	asl	R0
	call	@MainCycleTable(R0)
	; debug output
	call	DebugInfo	
	jmp	MainCycle

MainCycleTable:	
	.WORD	MainReset, MainMenu, MainClearPrepare, MainEpisodePrepare, MainScreenUp, MainEpisodeBeforePlay, MainGame, MainFadeOut, MainOverPrepare, MainOver, MainNextEpisode


; Menu Tiles - Id1, Id2, Id3 ... 
MenuTbl00:	.byte	00., 04., 30., 04., 31., 04., 00.
		.byte	121., 122., 123., 124., 125., 126., 127.
		.byte	00., 45., 44., 45., 44., 45., 00.
; Menu Texts - X, Y, Id ...
MenuTbl10:	.byte	013., 110., 00.,	013., 120., 01.,	013., 130., 02.
		.byte	013., 145., 03.,	013., 155., 04.,	013., 165., 05.
		.byte	013., 175., 06.,	013., 190., 07., 	014., 210., 08.
		.byte	0
		.even

; 0 - called after game reset - reset vars and draw main menu
MainReset:
	clr	R0
	.ppexe	#CmdFillScreen		; clear screen plane-0
	call	ClearScreen		; clear screen planes-1,2
	; variables from reset
	mov	#2., VSyncX		; game speed - #2 of 50Hz sync interrupt (25fps)
	movb	#1., TestSoundNum
	clr	KeyCombo		; 'combo' key must be cleared
	clrb	EpisodeDream		; must be cleared to draw full-colored sprites
	clrb	PlayerFlashing		; also must not flash in menu
	; screen prepare (clear)
	mov	#VADDR, R0		; reset lines table addrs (if stopped in a middle of changing)
	.ppexe	#CmdLinesFromR0	
	; put logo to buffer
	call	ClearVBuffer
	call	ClearLevel
	mov	#FieldDX*2+8.+Level, R5
	mov	#MenuTbl00, R0
	mov	#3, R3
10$:	mov	#7, R2
20$:	movb	(R0)+, (R5)+
	inc	R5
	sob	R2, 20$
	add	#FieldDX-7*2, R5
	sob	R3, 10$
	; prepare menu character walking
	clr	playerFollower
	mov	#80., PlayerX
	mov	#16., PlayerY
	clr	PlayerDir
	clr	PlayerAni
	mov	#2., PlayerSpr
	clr	plActing
	call	RedrawFull
	; controls text
	mov	#MenuTbl10, varAddr
	call	PrintTextLines
	; start some music
	mov	#1., R0			; music ID
	.ppexe	#CmdMusicPlay		; start music command
	; debug info
	mov	#160000-END, R0		; free CPU RAM
	mov	#400000-ENDVram12, R4	; free VRAM12
	.ppexe	#CmdDebugString
	; test sound number
	call	PrintSoundNum
	; go main menu
	inc	CurrentMode		; -> 1 (MainMenu)
	return


; 1 - main menu processing
MainMenu:
	; --- player walking ---
	mov	#playerObject, R0
	call	BufferObject
	call	DrawChanged
	; character animation
	bit	#^B11, FrameCount	; every 4th frame
	bne	30$
	inc	PlayerAni
	bic	#^B1111111111111100, PlayerAni
	tst	PlayerDir		; walking right?
	bne	22$			; nope - go 22
	mov	#2., PlayerSpr		; base walk right sprite
	add	#2., PlayerX
	cmp	PlayerX, #158.		; at the right edge?
	blt	24$
	mov	#158., PlayerX
	inc	PlayerDir		; walk left now
	br	24$
22$:	mov	#5., PlayerSpr
	sub	#2., PlayerX
	cmp	PlayerX, #64.
	bgt	24$
	mov	#64., PlayerX
	clr	PlayerDir
24$:	mov	PlayerAni, R0
	movb	SPPAniTable(R0), R0
	add	R0, PlayerSpr
30$:	; sound test start
	tst	KeyLeft
	beq	40$
	clr	KeyLeft
	decb	TestSoundNum
	bne	46$
	incb	TestSoundNum
	br	46$
40$:	tst	KeyRight
	beq	42$
	clr	KeyRight
	cmpb	TestSoundNum, #SND_MAX
	bge	46$
	incb	TestSoundNum
	br	46$
42$:	tst	KeyDown
	beq	50$
	clr	KeyDown
	movb	TestSoundNum, R0	; i don't think there will be more than 127 sounds
	.ppexe	#CmdSoundPlay
	br	50$
46$:	call	PrintSoundNum
50$:	; sound test end
	; sound on/off
	tst	KeyK2
	beq	52$
	clr	KeyK2
	comb	NoSound
	movb	NoSound, R0
	.ppexe	#CmdSoundOnOff
	mov	#MenuTbl10, varAddr	; re-print all menu 
	call	PrintTextLines		; (we don't need it all, but it's ok)
52$:	; ----------------------
	; test for start key
	tst	KeySpace
	beq	60$
	; go game prepare
	clr	KeySpace
	clr	Episode
	inc	CurrentMode		; ->2 (MainClearPrepare)
60$:	; 'combo' key - debug on|off
	call	CheckDebug
	return


; 2 - clear start vars prepare
MainClearPrepare:
	.ppexe	#CmdClrScrBottom
	.ppexe	#CmdHideScreen		; hide anything going on screen
	; episode 0 text output
	mov	#TXTID_EP0MSG, R0
	mov	#288., R2
	.ppexe	#CmdCenteredStr
	; unpack level & objects data from PPU vram
	mov	#GlobalLevel-200000, R0
	mov	#GlobalObj-200000, R1
	.ppexe	#CmdUnpackLevels
	; while PPU is unpacking - prepare screen background in CPU
	call	ClearScreen		; clear screen planes 1,2
	call	ScreenBackground	; fill with ////
	; clear player vars
	mov	#playerObject, R0
	mov	#playerObjectEnd-playerObject/2, R3
	clr	(R0)+
	sob	R3, .-2
	mov	#63., playerLifeMax	; set player life max for drawing box
	clr	playerLifeCur		; current life meter (not actual life)
	; reset already taken items list
	mov	#TakenItems-200000, PutA12
	mov	#TakenItemsEnd-TakenItems, R3
	clr	R1
	call	PutB12			; R1 to vaddr (0) (don't forget that procedure invalidates R2)
	sob	R3, .-4
	; TODO: some lenghty operations can be done here
	; wait for unpacking to finish 
	call	PpuWait
	; level is unpacked but it's with dirty high-bytes
	; fill screen plane 0
	mov	#177777, R0
	.ppexe	#CmdFillScreen
	; init tiles weights while PPU is filling plane 0
	call	InitTilesWeight		; finish init tiles
	; finish drawing
	call	DrawFieldBorder		; prepare game borders & item boxes
	call	ClearItems
	;
	inc	CurrentMode		; -> MainEpisodePrepare
	return


; 3 - game episode prepare
MainEpisodePrepare:
	clr	playerSprAdj		; no adjustment to player sprite
	clr	playerFollower		; no follower
	; modify global level according to episode (add|del obj, make passages etc)
	; TODO: make tables for this thing and put them into VRAM
	cmp	Episode, #2
	bne	22$
	; episode 2 - change boss to flashlight, remove light message, open door
	mov	#ChgObjE0201, R5	; replace boss to flashlight, remove 'need light' message
	call	ChangeGlobalObjects
	mov	#ChgTileE0201, R5	; open door
	call	ChangeGlobalTiles
22$:	cmp	Episode, #3
	bne	23$
	mov	#30., playerSprAdj	; switch player sprite to Yana
	inc	playerFollower		; set follower to Yan
	clr	plCurFolIdx		; index in follower tables
23$:	cmp	Episode, #4
	bne	24$	
	mov	#ChgObjE0401, R5	; episode 4 - remove tomb transition
	call	ChangeGlobalObjects
24$:	;
	; episode items
	call	RestoreItems		; restore items if they were backed up
	; episode variables
	mov	Episode, R0
	movb	EListDream(R0), EpisodeDream	; dreaming episodes?
	beq	32$
	call	BackupItems		; backup items before 'dream' episode
32$:	; player vars prepare
	clr	playerX
	clr	playerY
	movb	EListPlayerX(R0), playerX
	movb	EListPlayerY(R0), playerY
	movb	EListPlayerDir(R0), playerDir
	movb	EListPlayerSpr(R0), playerSpr
	mov	#PLSWALKING, playerState
	clr	playerAni
	clr	playerItemNew
	mov	playerLifeMax, playerLife
	clrb	playerFlashing		; no flashing at episode start
	; init level field (global->local)
	movb	#-1, glevelX			; -1 = not initialized
	movb	EListGlevX(R0), glevelNewX	; new global level coords
	movb	EListGlevY(R0), glevelNewY	;
	; vars init complete
	call	InitLevelField		; init level
	call	InitFollower		; init follower coords if any
	; update item box (needed if dream state was changed)
	call	UpdateItems		; draw player items
	call	SelectNewItem
	; go show screen
	call	RedrawFull
	call	PrepareFade
	inc	CurrentMode		; next mode -> fade in screen
	return


; 4 - make screen appear
MainScreenUp:
	call	FadeInOutTick
	.ppexe	#CmdFadeInScreen
	cmp	varY, #144.
	blo	10$
	mov	#2., VSyncX		; slow down to 25fps
	inc	CurrentMode		; next mode -> game post prepare episode
10$:	return


; 5 - last preparations before episode play
MainEpisodeBeforePlay:
	tst	Episode
	bne	10$
	clr	EpisodeVar0		; it's a boulders count at boss 0 for episode 0
	clr	EpisodeVar1		; >0 = can speak after get boulders
	; episode #0 - show message 
	; R1=[obj type][obj subtype], R5=msg #
	mov	#TOBJ_FRIEND*256.+TSUB_BOSS, R1
	mov	#TXTID_MSG1, R5
	call	EventShowMessage
10$:	inc	CurrentMode		; next mode - > main game cycle
	return

	
; 6 - game processing
MainGame:
	call	ProcessDelayedMsg
	call	DrawPlayerLife
	call	BufAllSprites
	call	DrawChanged
	; processing
	call	ProcItemKeys
	call	ProcessPlayer
	call	Acting
	call	ProcessHits
	call	ProcessObjects
	call	ProcessPlayerOut
	; test debug key 'next episode'
	tstb	DebugMode
	beq	10$
	tst	KeyK2
	beq	10$
	clr	KeyK2
	cmp	Episode, #MAX_EPISODES	; max episode incl. test one
	bge	10$
	call	NextEpisode
10$:	; test for game over
	tst	playerLife
	bgt	99$
	tstb	DebugMode		; continue if debug
	bne	99$
	call	DrawPlayerLife		; draw life at zero just in case
	mov	#-1, Episode		; -1 is a game over
	call	PrepareFade
	inc	CurrentMode		; next mode - fade out screen
99$:	return


; 7 - fade out screen
MainFadeOut:
	call	FadeInOutTick
	.ppexe	#CmdFadeOutScreen
	cmp	varY, #144.
	blo	90$
	.ppexe	#CmdClrScrBottom
	.ppexe	#CmdHideScreen		; hide anything going on screen
	inc	CurrentMode
90$:	return


; 8. - end of episode or game over prepare
MainOverPrepare:
	; print next episode message (or game over if Episode = -1)
	mov	Episode, R1
	clr	R0
	bisb	EListMsg(R1), R0
	mov	#288., R2
	.ppexe	#CmdCenteredStr
	; game over or not?
	tst	Episode
	bmi	85$
	call	CopyLocalGlobal		; copy changed level tiles/objects back to vram12
	inc	CurrentMode		; +2 is next episode
85$:	inc	CurrentMode
90$:	return


; 9. - game over
MainOver:
	dec	varY
	bgt	99$
	clr	CurrentMode
99$:	return


; 10. - next episode transition
MainNextEpisode:
	dec	varY
	bgt	99$
	call	PrepareFade		; next will be fade in screen
	mov	#3., CurrentMode	; next episode prepare
99$:	return


; prepare vars for fade in fade out
PrepareFade:
	clr	varY			; for screen fade in
	mov	#1, varDY		;
	mov	#1., VSyncX		; speed up to 50fps
	return

; adjust vars for fade in fade out
FadeInOutTick:
	mov	varDY, R0
	asr	R0
	asr	R0
	add	R0, varY
	cmp	varDY, #24.
	bhis	2$
	inc	varDY
2$:	mov	varY, R0
	return


; next episode preparation
NextEpisode:
	inc	Episode			; next episode
	call	PrepareFade		; prepare fadeout vars
	inc	CurrentMode		; set next game mode to fade out
	return


; put all to buffer
BufAllSprites:
	call	BufferObjects
	; buffer player using item (acting)
	mov	plActing, R0
	asl	R0
	call	@BufActTable(R0)
	; buffer player
	movb	EpisodeDream, R0	; save 'dream' state
	mov	R0, -(SP)
	bne	10$			; no flashing at dream episodes
	movb	playerFlashing, R0	; set 'dream' as flashing bit
	bic	#^B1111111111111011, R0
	movb	R0, EpisodeDream
10$:	; draw player
	mov	playerSpr, R1
	mov	R1, -(SP)
	; save player sprite and coordinates for a follower
	tst	playerFollower
	beq	20$
	mov	plCurFolIdx, R2
	bic	#^B1111111111110000, R2	; 16 moves to save maximum
	asl	R2
	mov	playerX, followerX(R2)
	mov	playerY, followerY(R2)
	dec	R1			; player sprite # from zero
	add	playerFollower, R1	; follower sprite #
	mov	R1, followerSpr(R2)
	inc	plCurFolIdx
20$:	; buffer it
	mov	#playerObject, R0
	add	playerSprAdj, playerSpr
	call	BufferObject
	; restore player sprite (if was changed)
	mov	(SP)+, playerSpr
	; draw follower if any
	tst	playerFollower
	beq	30$
	mov	plCurFolIdx, R2
	sub	#15., R2
	bic	#^B1111111111110000, R2	; 16 moves only
	asl	R2
	mov	followerX(R2), drawX
	mov	followerY(R2), drawY
	mov	followerSpr(R2), drawSpr
	mov	#drawObject, R0
	call	BufferObject
30$:	mov	(SP)+, R0		; restore 'only blue draw'
	movb	R0, EpisodeDream
	; process player flashing after drawing
	tstb	playerFlashing
	ble	50$
	decb	playerFlashing
50$:	; end of player drawing
	return


; buffer currently using item
BufActTable:
	.WORD	RetFunc, RetFunc, BufActSpade

BufActSpade:
	mov	plActingArg1, R0	; direction (0->,1,2,3 clockwise)
	clr	drawSpr
	bisb	spadeSprites(R0), drawSpr
	mov	plActingArg2, R3	; animation # (0,1,2,3)
	asl	R0			; dir*4 (bytes)
	asl	R0
	add	R3, R0
	movb	spadeActDX(R0), R1
	movb	spadeActDY(R0), R2
	; add coords and check boundaries
	add	playerX, R1
	bpl	2$
	clr	R1
	br	4$
2$:	cmp	R1, #FieldDX*16.-16.
	blos	4$
	mov	#FieldDX*16.-16., R1
4$:	add	playerY, R2
	bpl	6$
	clr	R2
	br	8$
6$:	cmp	R2, #FieldDY*16.-16.
	blos	8$
	mov	#FieldDY*16.-16., R2
8$:	; set hitpoint, on #1 animation it hits
	cmp	R3, #1
	bne	20$
	tst	hitpointX		; do not set if not asked to
	bge	20$
	mov	plActingArg1, R0
	movb	spadeHitDX(R0), R3
	movb	spadeHitDY(R0), R4
	add	R1, R3
	add	R2, R4	
	mov	R3, hitpointX
	mov	R4, hitpointY
20$:	; draw
	mov	R1, drawX
	mov	R2, drawY
	mov	#drawObject, R0
	call	BufferObject
	return

spadeSprites:	.byte	20., 21., 22., 23.
spadeActDX:	.byte	3,5,3,0, 0,0,0,0, -3,-5,-3,0, 0,0,0,0
spadeActDY:	.byte	1,1,1,0, 6,8.,6,0, 1,1,1,0, -7,-9.,-7,0
spadeHitDX:	.byte	15., 8., 0., 8.
spadeHitDY:	.byte	10., 15., 10., 0.


; mark level bits as 'drawed' and draw object sprite in buffer
; R0-object addr [TYPE|SUBTYPE, SprID, X, Y]
BufferObject:
	mov	4(R0), R1		; X
	mov	6(R0), R2		; Y
	mov	R1, R3			; save them for later use
	mov	R2, R4
	bic	#^B1111111100001111, R3 ; levelX/16*16
	bic	#^B1111111100001111, R4	; levelY/16*16
	ash	#-4, R3			; convert X,Y to level offset
	mov	R3, R5			; R5 = levelX
	add	R4, R5			; + levelY*16 = level offset
	asl	R5
	add	#Level, R5		; level addr -> R5
	mov	#^B1000000000000000, R4	; 'tile was changed' bit
	bis	R4, (R5)		; set bit 'was used in drawing' on tile
	mov	#2, R3
	bit	#^B1111, R1		; need to mark tile X+1?
	beq	10$
	bis	R4, 2(R5)
	dec 	R3
10$:	bit	#^B1111, R2		; need to mark Y+1?
	beq	20$
	bis	R4, 32.(R5)
	dec	R3			; need to mark X+1,Y+1?
	bne	20$
	bis	R4, 34.(R5)
20$:	mov	2(R0), R0		; sprite ID, X,Y already in R1,R2
	bic	#^B1111111100000000, R0	; some objects have arg #1 in high byte
	call	BufSprite
	return


; draw changed parts of level from buffer to screen and redraw bgr to buffer
; 3007 (w/o animated code 2 sprites rounded) 2636 (6 animated 2 sprites rounded)
DrawChanged:
	mov	#LevelEnd, R5		; last level unit addr + 2
	mov	#CLV_LOCAL_DY, R2	; traverse backwards
10$:	mov	#CLV_LOCAL_DX, R1	;
20$:	mov	-(R5), R0		; decrease addr and get level unit
	; animation 
	bit	#^B0000100000000000, R0	; animated bit
	beq	22$			; nothing to do
	bit	#^B11, FrameCount	; animation change?
	bne	22$
	mov	R0, R4			; change tile #
	inc	R4
	bic	#^B1111111111111100, R4
	bic	#^B0000000000000011, R0
	bis	R4, R0			; tile # was changed
	bis	#^B1000000000000000, R0	; set as 'changed' (!) bad but ok for now
22$:	; check current + previous bits
	bit	#^B1100000000000000, R0
	beq	90$
	bit	#^B0010000000000000, R0	; check darken
	bne	30$
	; draw buffer to screen
	mov	R5, -(SP)
	mov	R2, -(SP)
	mov	R1, -(SP)
	mov	R0, -(SP)
	call	Buf2Scr16
	mov	(SP)+, R0
	mov	(SP)+, R1
	mov	(SP)+, R2
	mov	(SP)+, R5
	; if current - restore buffer
30$:	bit	#^B1000000000000000, R0
	beq	40$
	; clear current and set previous bits, and restore
	bic	#^B1000000000000000, R0
	bis	#^B0100000000000000, R0
	mov	R5, -(SP)
	mov	R2, -(SP)
	mov	R1, -(SP)
	mov	R0, -(SP)
	call	BufTile
	mov	(SP)+, R0
	mov	(SP)+, R1
	mov	(SP)+, R2
	mov	(SP)+, R5
	br	50$
40$:	; clear 'previous' bit
	bic	#^B0100000000000000, R0
50$:	mov	R0, (R5)
90$:	dec	R1
	bge	20$
	dec	R2
	bge	10$
	return
;22426

; draw all level with respect to darkened tiles
DrawLevelDark:
	mov	#LevelEnd, R5		; last level unit addr + 2
	mov	#CLV_LOCAL_DY, varY	; traverse backwards
10$:	mov	#CLV_LOCAL_DX, varX	;
20$:	mov	-(R5), R0		; decrease addr and get level unit
	; draw or clear
	mov	varX, R1
	mov	varY, R2
	mov	R5, -(SP)
	bit	#^B0010000000000000, R0
	beq	30$
	call	Clr2Scr16
	br	40$
30$:	call	Buf2Scr16
40$:	mov	(SP)+, R5
	dec	varX
	bge	20$
	dec	varY
	bge	10$
	return


; buffer all tiles
BufAllTiles:
	mov	#LevelEnd, R5
	mov	#FieldDY, R2
10$:	mov	#FieldDX, R1
20$:	mov	-(R5), R0
	bic	#^B1111111100000000, R0	; clear all flags except 'darkened'
;	bis	#040000, (R5)		; mark tile as 'recently changed' also
	mov	R1, -(SP)
	mov	R2, -(SP)
	mov	R5, -(SP)
	dec	R1
	dec	R2
	call	BufTile
	mov	(SP)+, R5
	mov	(SP)+, R2
	mov	(SP)+, R1
	sob	R1, 20$
	sob	R2, 10$
	return


; invalidate all tiles and redraw all 
RedrawFull:
	call	BufAllTiles
	call	BufAllSprites
	call	DrawLevelDark
	clr	DelayedMessage		; clears delayed message in case of screen transitions etc
	return


; //////////////////////////////////////////////////////////////////////////////
; // Level routines 
; //////////////////////////////////////////////////////////////////////////////

; clear level
ClearLevel:
	mov	#Level, R0
	mov	#LevelEnd-Level/2, R3
	clr	(R0)+
	sob	R3, .-2
ClearLevelObjects:
	mov	#LevelObj, R0
	mov	#LevelObjEnd-LevelObj/2, R3
	clr	(R0)+
	sob	R3, .-2
	return


; copy level data global -> local 
CopyGlobalLocal:
	call	SetVreg			; R4=176640, R5=176642
	; first - copy level tiles
	call	gCoordsLVram		; set source in (R4)
	mov	#Level, R2		; set dest in R2
	; copy FieldDX * FieldDY words
	mov	#FieldDY, R3
10$:	mov	#FieldDX, R1
20$:	mov	(R5), (R2)+
	inc	(R4)
	sob	R1, 20$
	add	#CGL_DX-FieldDX, (R4)
	sob	R3, 10$
	; copy level objects
	call	ClearLevelObjects
	call	PrepareCopyObjects
	mov	R1, GetA12		; GetA12 = vram addr relative to 200000
	; R3 = obj count
	; R2 = #LevelObj
	; copy objects cycle
30$:	call	GetB12			; R0(low byte) = object type (3-bits) | subtype (5-bits)
	; convert to word [subtype | type]
	asl	R0
	asl	R0
	asl	R0
	asrb	R0
	asrb	R0
	asrb	R0
	bic	#^B1111100011100000, R0
	swab	R0
	mov	R0, (R2)+		; store [subtype | type] at object word 1
	call	GetB12			; R0 = argument #0 (spr#)
	clr	R1
	bisb	R0, R1
	call	GetB12			; R0 = argument #1
	swab	R0
	clrb	R0
	bis	R0, R1			; R1 = [arg #1 | arg #0] word
	mov	R1, (R2)+		; store at object word 2
	call	GetB12			; R0 = coords
	bic	#^B1111111100000000, R0		
	ash	#4, R0			; convert X to pixels
	clr	R1
	bisb	R0, R1
	mov	R1, (R2)+		; put X
	clrb	R0
	swab	R0			; R0=Y
	ash	#4, R0			; convert Y to pixels
	mov	R0, (R2)+		; put Y
	sob	R3, 30$	
	return


; copy level data local -> global
CopyLocalGlobal:
	call	SetVreg			; R4=176640, R5=176642
	; copy level tiles
	call	gCoordsLVram		; set dest in (R4)
	mov	#Level, R2		; set source in R2
	; copy FieldDX * FieldDY words
	mov	#FieldDY, R3
10$:	mov	#FieldDX, R1
20$:	mov	(R2)+, (R5)
	inc	(R4)
	sob	R1, 20$
	add	#CGL_DX-FieldDX, (R4)
	sob	R3, 10$
	; copy level objects
	call	PrepareCopyObjects
	mov	R1, PutA12		; PutA12 = vram addr relative to 200000
	mov	R2, R5			; R5 = #LevelObj
	; R3 = count
	; copy objects cycle
30$:	movb	(R5)+, R1		; type
	ash	#5, R1
	bisb	(R5)+, R1		; subtype
	call	PutB12			; (!) trashes R2
	movb	(R5)+, R1		; arg #0
	call	PutB12			; put arg #0
	movb	(R5)+, R1		; arg #1
	call	PutB12			; put arg #1
	mov	(R5)+, R1		; X-coord
	add	#8., R1			; adjust to center by X
	ash	#-4, R1			; convert to X-tile
	bic	#^B1111111111110000, R1	; clear unused bits
	mov	(R5)+, R0		; Y-coord
	add	#8., R0			; adjust to center by Y
	bic	#^B1111111100001111, R0	; convert to Y-tile and *16
	bis	R0, R1
	call	PutB12			; put level-unit coords
	sob	R3, 30$	
	return


; set registers for global <-> local objects copy
; sets: R1 - GlobalObj for level (relative), R2 - LevelObj, R3 - objects count
PrepareCopyObjects:
	; summ GlobalObjLen for this level index
	call	gCoords2R3		; R3 = global level index
	mov	#GlobalObjLen-200000, GetA12
	clr	R1
22$:	call	GetB12			; R0 = level objects count
	dec	R3			; are we at needed level?
	bmi	24$			; yes - exit cycle
	add	R0, R1
	br	22$
24$:	asl	R1			; TODO: change to R1=R1*COBJ_LEN?
	asl	R1			; now object size is 4 bytes
	; R1 = offset from GlobalObj
	; R0 = level objects count
	add	#GlobalObj-200000, R1
	mov	R0, R3			; R3 = level objects count
	mov	#LevelObj, R2		; R2 = dest addr
	return


; global level coords into index -> R0
gCoords2R3:
	movb	glevelY, R3
	asl	R3
	asl	R3
	bisb	glevelX, R3
	return


; set vaddr to global level offset
gCoordsLVram:
	movb	glevelY, R0
	mul	#CLV_LOCAL_DY*CGL_DX, R0
	mov	R1, R2			; R2 = starting glevelY offset (units)
	movb	glevelX, R0
	mul	#CLV_LOCAL_DX, R0
	add	R1, R2
	asl	R2			; R2 = offset in global level (real)
	add	#GlobalLevel-200000, R2	; R2 = addr rel to vram12
	sec	
	ror	R2			; R2 = vram #
	mov	R2, (R4)
	return
	
; update global tiles weights
InitTilesWeight:
	call	SetVreg
	mov	#GlobalLevel-200000, R0
	sec
	ror	R0
	mov	R0, -(SP)		; (!) save to stack, don't forget to restore
	mov	R0, (R4)		; vaddr -> (R4) 176640
	mov	#CGL_DY*CGL_DX, R3
10$:	mov	(R5), R0
	bic	#^B1111111100000000, R0	; clear level tile attributes
	clr	R1
	bisb	TilesWeight(R0), R1
	swab	R1
	bis	R1, R0
	; change variation for animated tile
	bit	#^B0000100000000000, R0	; is animated?
	beq	20$			; skip then
	mov	R0, R1			; need to add some variations
	add	R3, R1			; to the last 2 bits of animated tile
	bic	#^B1111111111111100, R1
	bic	#^B0000000000000011, R0
	bis	R1, R0
20$:	mov	R0, (R5)
	inc	(R4)
	sob	R3, 10$
	; set dark tiles from darken squares table
	mov	#GlobalDarken-200000, R0
	sec
	ror	R0			; R0 <- darken table addr
30$:	; start darken square
	mov	R0, (R4)
	add	#2, R0
	mov	(R5), R1		; R1 <- offset in global field
	beq	60$			; zero? exit
	inc	(R4)			; advance to next word
	mov	(R5), R2		; R2 <- [height][width]
	mov	R2, R3
	clrb	R3
	swab	R3			; R3 <- height
	bic	#^B1111111100000000, R2	; R2 <- width
	mov	(SP), (R4)		; set vaddr to global level start
	add	R1, (R4)		; add offset (square upper left corner)
	mov	R2, R1			; save width
	; square darken cycle
40$:	mov	R1, R2
50$:	bis	#^B0010000000000000, (R5)	; darken bit
	inc	(R4)
	sob	R2, 50$
	sub	R1, (R4)		; rewind vaddr
	add	#CGL_DX, (R4)		; advance to next line
	sob	R3, 40$
	br	30$
60$:	tst	(SP)+			; (!) restore SP
	return


; create level field
InitLevelField:
	tstb	glevelX			; was previous level?
	bmi	10$			; wasn't - skip saving
	call	CopyLocalGlobal		; or else save it in vram
10$:	movb	glevelNewX, glevelX
	movb	glevelNewY, glevelY
	call	CopyGlobalLocal		; read level from vram
	return


; make changes in global objects (for episode transitions)
; R5 - change object sequence (glx, gly, objnum, [type|subtype], arg#0, arg#1, coords)
ChangeGlobalObjects:
	movb	(R5)+, glevelX
	bmi	99$
	movb	(R5)+, glevelY
	call	PrepareCopyObjects	; -> R1 - GlobalObj for level 0,0 (relative)
	movb	(R5)+, R0		; objnum -> R0 (not need to clear high-byte)
	asl	R0			; TODO? *COBJ_LEN?
	asl	R0
	add	R0, R1
	mov	R1, PutA12		; TOBJ_ITEM*32+ITEM_LIGHT,spr#,0,y*16+x
	movb	(R5)+, R1		; [type|subtype] (type is 3-bits, subtype-5bits)
	call	PutB12
	movb	(R5)+, R1		; arg#0
	call	PutB12
	movb	(R5)+, R1		; arg#1
	call	PutB12
	movb	(R5)+, R1		; coords
	call	PutB12
	br	ChangeGlobalObjects
99$:	return


; make change in global tile field
; R5 - change tile sequence (global offset, new tile # ... ... 0)
ChangeGlobalTiles:
	mov	(R5)+, R0		; R0 = global offset
	bmi	99$
	mov	(R5)+, R1		; R1 = new tile #
	mov	R5, -(SP)		; save pointer
	call	SetVreg			; 
	mov	#GlobalLevel-200000, R2	; get global level addr
	sec				;
	ror	R2			; R2 - vaddr
	add	R0, R2			; add offset
	mov	R2, (R4)		; set vaddr
	; need to get new tile weight
	movb	TilesWeight(R1), R0	; we don't need clear upper byte, weights are 5-bits
	swab	R0			; weights are in upper byte
	bis	R0, R1			; R1 = new tile # with weight
	bic	#^B0001111111111111, (R5)	; keep darken and current draw states
	bis	R1, (R5)
	mov	(SP)+, R5
	br	ChangeGlobalTiles
99$:	return


; //////////////////////////////////////////////////////////////////////////////
; // Player movements 
; //////////////////////////////////////////////////////////////////////////////

ChkBlocksEmpty:		.byte	0
ChkBlocksClimb:		.byte	0
ChkBlocksStand:		.byte	0
ChkBlocksSolid:		.byte	0

;	0 1 2 3 [4 5 6 7 8 9 10 11] 12 13 14 15

; check if player intersects with blocks, R1,R2 - X,Y, invalidates them
CheckAvail:
	clr	ChkBlocksEmpty
	clr	ChkBlocksEmpty+2
	add	#4., R1			; X+3
	add	#2., R2			; Y+2
	call	CheckAvailPoint
	beq	90$			; it's solid
	add	#7., R1			; X+10
	call	CheckAvailPoint
	beq	90$
	add	#13., R2		; Y+15
	call	CheckAvailPoint
	beq	90$
	sub	#7., R1
	call	CheckAvailPoint
	beq	90$
	clc
	return
90$:	incb	ChkBlocksSolid		; set solid
	sec
	return


; set checked blocks from level point R1,R2 (x,y), return type and flag of passable (Z - not passable)
; 0 - nothing, 1 - can climb, 2 - can stand, 3 - solid
CheckAvailPoint:
	; (!) do not modify R1,R2,R5
	mov	R1, R3
	mov	R2, R4
	; coords to level addr
	bic	#^B1111, R4		; R4 = levelY*16
	ash	#-4, R3			; R3 = levelX
	add	R3, R4			; level offset in units
	asl	R4			; level offset in words
	mov	Level(R4), R0
	swab	R0
	bic	#^B1111111111111100, R0	; 2-bits for tile weight
	incb	ChkBlocksEmpty(R0)
	cmp	R0, #3
	return


; get tile at pixel position R1, R2 (x,y)
; returns: R0 - tile word
GetTileAt:
	mov	R1, R3
	mov	R2, R4
	; coords to level addr
	bic	#^B1111, R4		; R4 = levelY*16
	ash	#-4, R3			; R3 = levelX
	add	R3, R4			; level offset in units
	asl	R4			; level offset in words
	mov	Level(R4), R0
	return


KeysRightLeft:
	; check right 
1$:	tst	KeyRight
	beq	11$
	mov	#PLDRIGHT, playerDir
	inc	playerDX
	bpl	2$
	mov	#1, playerDX
2$:	cmp	playerDX, #2
	ble	3$
	mov	#2, playerDX
3$:	return
	; check left
11$:	tst	KeyLeft
	beq	21$
	mov	#PLDLEFT, playerDir
	dec	playerDX
	bmi	12$
	mov	#-1, playerDX
12$:	cmp	playerDX, #-2
	bge	13$
	mov	#-2, playerDX
13$:	return
	; no right nor left
21$:	clr	playerDX
	return

KeysUpDown:
	; check down
1$:	tst	KeyDown			; moving down?
	beq	11$
	inc	playerDY		; inc down increment
	bpl	2$			; 
	mov	#1, playerDY		; if zero or negative - reset to +1
2$:	cmp	playerDY, #2		; max increment?
	ble	3$
	mov	#2, playerDY		; set to max increment +2
3$:	return
	; check up
11$:	tst	KeyUp
	beq	21$
	dec	playerDY
	bmi	12$
	mov	#-1, playerDY
12$:	cmp	playerDY, #-2
	bge	13$
	mov	#-2, playerDY
13$:	return
	; no right nor left
21$:	clr	playerDY
	return
	
ProcessPlayerDX:
	tst	playerDX
	bne	10$
	return
10$:	mov	playerX, R1
	mov	playerY, R2
	add	playerDX, R1
	; test for collisions with blocks
15$:	call	CheckAvail
	bcs	20$
	add	playerDX, playerX
	return
20$:	tst	playerDX
	bpl	30$
	inc	playerDX
	bne	10$
	return
30$:	dec	playerDX
	bne	10$
	return


ProcessPlayerDY:
	tst	playerDY
	bne	10$
	return
10$:	mov	playerX, R1
	mov	playerY, R2
	add	playerDY, R2
	call	CheckAvail
	bcs	20$
	add	playerDY, playerY
	return
20$:	tst	playerDY
	bpl	30$
	inc	playerDY
	bne	10$
	return
30$:	dec	playerDY
	bne	10$
	return


; if nothing under player - he can fall
TransFalling:
	mov	playerX, R1
	mov	playerY, R2
	mov	R2, R5
	bic	#^B1111111111110000, R5		; R5=Y%16
	bne	80$				; well.. technically we can walk if Y%16 != 0, but we shouldn't	
	add	#16., R2			; Y-coord 1px under feet
	; first point X+4 check
	add	#4, R1
	call	CheckAvailPoint			; (!) do no modify R5 there
	beq	90$				; solid below - can't fall at all
	; climb/stand below - can't fall either
	tst	keyDown				; do not check if down key is pressed
	bne	10$
	tst	R0				; something is below?
	bne	90$				; yes - can't fall
10$:	; second point X+11 check
	add	#7, R1
	call	CheckAvailPoint
	beq	90$
	tst	keyDown
	bne	20$
	tst	R0	
	bne	90$
20$:	; set to 'falling'
	inc	playerY
80$:	clr	playerDY
	mov	#PLSFALLING, playerState	; seems we can fall
	sec
	return
90$:	clc
	return

; test for up key and if can jump
TransJumping:
	tst	KeyUp
	beq	99$
	mov	#PLSJUMPING, playerState
	clr	jumpVelocity
	sec
	return
99$:	clc
	return

; test for up|down keys and if can climb
; also test for jump down from 'stand' blocks if walking on them
TransClimbing:
	; down key pressed
	tst	KeyDown				; can climb down if ladder is under player
	beq	50$				; and nothing blocks
	clr	ChkBlocksEmpty			; clear 'empty' and 'climb' blocks count
	mov	playerX, R1
	mov	playerY, R2
	add	#16., R2
	add	#4, R1
	call	CheckAvailPoint
	beq	99$				; if solid obj under the player
	add	#7, R1
	call	CheckAvailPoint
	beq	99$
	tstb	ChkBlocksClimb			; if was climbing block under	
	beq	99$
	; seems we can climb down
	inc	playerY				; immediate climb 1 pixel down
	br	90$
50$:	; up key pressed
	tst	KeyUp				; can climb up if ladder beneath the player
	beq	99$
	mov	playerX, R1
	mov	playerY, R2
	call	CheckAvail			; full check (all points)
	tstb	ChkBlocksClimb
	beq	99$
90$:	; switch to climbing state
	clr	playerDY
	mov	#PLSCLIMBING, playerState
	sec
	return
99$:	clc
	return

; walking left/right
; transitions to climbing, jumping, falling
PlayerWalking:
	; check transitions - order MATTERS 
	; e.g. to can jump off the edge from tunnel
	; jumping must be checked before falling
	call	TransClimbing
	bcs	99$
	call	TransJumping
	bcs	99$
	call	TransFalling
	; it's better to continue movement even if falling already
	; so here will be no 'bcs 99$'
	;
	; set playerDX from keys and process it
	call	KeysRightLeft
	call	ProcessPlayerDX
	; standing sprites
	mov	#5, playerSpr
	cmp	playerDir, #PLDRIGHT
	bne	10$
	mov	#2, playerSpr
10$:	; testing for movement
	tst	playerDX
	beq	30$
	mov	PlayerAni, R0
	movb	SPPAniTable(R0), R0
	add	R0, PlayerSpr
	inc	playerAni
	bic	#^B1111111111111100, playerAni
	br	99$
30$:	; standing still - maybe apply 'acting' modification to animation
	tst	plActing
	beq	99$
	dec	playerSpr
99$:	return


JumpFallSprites:
	mov	#6, playerSpr
	cmp	playerDir, #PLDRIGHT
	bne	10$
	mov	#1, playerSpr
10$:	return


PlayerFallingDY:
	; first - check vertical moving ranges [1..4]
	tst	playerDY
	bgt	10$
	mov	#1, playerDY
	return
10$:	cmp	playerDY, #4
	ble	12$
	mov	#4, playerDY
	; check blocks below player
12$:	mov	playerX, R1
	mov	playerY, R2
	add	playerDY, R2
	add	#4, R1				; X+4
	add	#15., R2			; Y+DY+15
	call	CheckAvailPoint			; check coords, return Z if solid
	beq	20$				; solid object - unable to move
	mov	R0, R5				; return value to temporary var
	add	#7, R1				; X+11
	call	CheckAvailPoint			; check next point coords
	beq	20$				; solid object - unable to move	
	bis	R0, R5				; to check both points
	beq	30$				; nothing under player - continue to move
	; R5 = 1|2 ladder or stand
	bit	#2, R5				; is it 'stand' block?
	beq	14$				; no 'stand' block, go check climb
	; stand block below can't use DY if (Y+15)/16 != (Y+15+DY)/16
	mov	R2, R3
	sub	playerDY, R3			; R3=Y+15
	ash	#-4, R3				; (Y+15)/16
	ash	#-4, R2				; (Y+16+DY)/16
	cmp	R2, R3				; can we move by DY?
	bne	20$				; no, can't
	br	30$
14$:	; climb block below
	cmp	playerDY, #2			; 'climb' blocks are passable with falling 
	bgt	30$				; if player is moving faster than 2px speed
20$:	; unable to move further, decrease speed and try again
	dec	playerDY
	bne	10$				; still can try to move?
	mov	#PLSWALKING, playerState	; unable to move even 1px down
	return
30$:	; can move down, modify coords and increase speed
	add	playerDY, playerY
	inc	playerDY
	return

; london bridge is falling down
; can stop by solid block anywhere or by stand block (varies)
PlayerFalling:
	call	TransClimbing			; can change to climbing if ladder is behind
	bcs	99$
	call	PlayerFallingDY
	call	KeysRightLeft
	call	ProcessPlayerDX
	call	JumpFallSprites
99$:	return
	

PlayerJumpingDY:
	clr	@#80$				; clear sound start checks
	mov	jumpVelocity, R0
	bne	10$				; sound start check #1
	inc	@#80$				; if R0=0 - it's starting of jump
10$:	inc	jumpVelocity	
	movb	jumpTableDY(R0), R0
	mov	R0, playerDY
	beq	90$
	mov	playerX, R1
	mov	playerY, R2
	add	R0, R2
	call	CheckAvail
	bcs	90$
	add	playerDY, playerY
	tst	(PC)+				; sound start check #2
80$:	.word	0
	beq	99$
	mov	#SND_JUMP, R0
	.ppexe	#CmdSoundPlay
	return
90$:	clr	playerDY
	mov	#PLSFALLING, playerState
99$:	return
	

; jumping
; transitions to climbing, falling
PlayerJumping:
	call	TransClimbing			; can change to climbing if ladder is behind
	bcs	99$
	call	PlayerJumpingDY
	call	KeysRightLeft
	call	ProcessPlayerDX
	call	JumpFallSprites
99$:	return


; climbing ladders
; transitions to walking if out of ladder
PlayerClimbing:
	; abort climbing?
	mov	playerX, R1
	mov	playerY, R2
	call	CheckAvail
	tstb	ChkBlocksClimb
	bne	10$
	mov	#PLSWALKING, playerState
	clr	KeyUp				; release UP for not jumping immediately from ladder
	return
10$:
	call	KeysRightLeft
	call	KeysUpDown
	call	ProcessPlayerDX
	call	ProcessPlayerDY

	mov	#8., playerSpr
	mov	playerDX, R0
	bis	playerDY, R0
	bne	30$
	clr	playerAni
	br	40$
30$:	mov	playerAni, R0
	movb	SPPAniTable(R0), R0
	add	R0, playerSpr
	tst	playerDY			; both animations are look same
	bpl	32$				; so do we need this?
	inc	playerAni
	inc	playerAni
32$:	dec	playerAni
	bic	#^B1111111111111100, playerAni	
40$:
	return
	
	
PlayerDying:
	return


; light square x,y [R0, R1]
; R2, R3 must be set to appropriate 'darken' and 'previous' bits
PLightXY:
	mov	R0, R4				; square X
	blt	99$				; if negative - exit
	cmp	R4, #CLV_LOCAL_DX		; check out of DX
	bgt	99$
	mov	R1, R5
	blt	99$
	cmp	R5, #CLV_LOCAL_DY
	bgt	99$
	ash	#4, R5				; square Y * 16
	add	R4, R5				; R5 = level offset in units
	asl	R5				; -> to words
	add	#Level, R5			; R5 = level addr
	bit	R2, (R5)
	beq	99$
	bic	R2, (R5)
	bis	R3, (R5)
99$:	return

PLightSquare:
	mov	#^B0010000000000000, R2		; 'darkened' bit
	mov	#^B0100000000000000, R3		; 'previous' bit
	mov	#-4, R4
	mov	#8., R5
	mov	playerX, R0
	add	R5, R0
	ash	R4, R0
	mov	playerY, R1
	add	R5, R1
	ash	R4, R1
	dec	R0
	dec	R1
	call	PLightXY
	inc	R0
	call	PLightXY
	inc	R0
	call	PLightXY
	inc	R1
	call	PLightXY
	dec	R0
	call	PLightXY
	dec	R0
	call	PLightXY
	inc	R1
	call	PLightXY
	inc	R0
	call	PLightXY
	inc	R0
	call	PLightXY
	return

PLightLevel:
	return

	
PStateTable:
	.word	PlayerWalking, PlayerFalling, PlayerJumping, PlayerClimbing, PlayerDying

; main process player function
ProcessPlayer:
	; process player light
	bit	#1, FrameCount			; every 2nd frame is enough
	bne	10$
	tstb	LightType
	beq	10$
	call	PLightSquare
10$:	; process player states
	mov	playerState, R0
	asl	R0
	call	@PStateTable(R0)
	; check for dangerous tile below player (not every frame)
	bit	#1, FrameCount
	beq	30$
	mov	playerX, R1
	mov	playerY, R2
	add	#6., R2
	add	#3., R1
	call	GetTileAt
	bit	#^B0001000000000000, R0		; hazardous bit
	bne	20$
	add	#9., R1
	call	GetTileAt
	bit	#^B0001000000000000, R0		; hazardous bit
	bne	20$
	br	30$
20$:	mov	#16., R0
	call	DecreaseLife
30$:	; check for closed door in front of player direction
	tstb	HaveKeys			; no keys? do not bother checking for door then
	beq	40$
	mov	playerX, R1			; TODO: we don't need to update R1, R2 i think
	mov	playerY, R2
	add	#8., R2
	cmp	playerDir, #PLDRIGHT
	bne	35$
	add	#14., R1
	call	CheckAndOpenDoor
	br	40$
35$:	cmp	playerDir, #PLDLEFT
	bne	40$
	add	#2., R1
	call	CheckAndOpenDoor
40$:	;
	return


; checks and opens door at point (x,y) (R1, R2)
CheckAndOpenDoor:
	call	GetTileAt			; returns also R4 = level offset
	cmpb	R0, #60.			; TODO: change to smth like TILE_DOOR
	bne	90$
	inc	R0				; 'open' door
	bic	#^B0000001100000000, R0		; clear 'unpassable' flag
	mov	R0, Level(R4)
	mov	#SND_OPENDOOR, R0
	.ppexe	#CmdSoundPlay
	mov	#ITEM_KEY, R1
	call	RemoveOneItem
	call	UpdateItems
90$:	return


; decrease player life by R0 value
; set player flashing bit, set sound?
DecreaseLife:
	sub	R0, playerLife
	bge	10$
	clr	playerLife
10$:	movb	#16., playerFlashing
	return


; check for out-of-screen and change level
ProcessPlayerOut:
	tst	playerX
	bpl	10$
	clr	playerX
	clr	playerDX
	tstb	glevelX
	beq	99$
	mov	#240., playerX
	decb	glevelNewX	
	br	90$
10$:	cmp	playerX, #240.
	ble	20$
	mov	#240., playerX
	clr	playerDX
	cmpb	glevelX, #CGL_LEV_DX-1
	bge	99$
	clr	playerX
	incb	glevelNewX
	br	90$	
20$:	tst	playerY
	bpl	30$
	clr	playerY
	clr	playerDY
	tstb	glevelY
	beq	99$
	mov	#208., playerY
	decb	glevelNewY
	br	90$
30$:	cmp	playerY, #208.
	ble	99$
	mov	#208., playerY
	clr	playerDY
	cmpb	glevelY, #CGL_LEV_DY-1
	bge	99$
	clr	playerY
	incb	glevelNewY	
90$:	call	InitLevelField
	call	InitFollower
	call	RedrawFull
99$:	return


; initialize follower coordinates to player
InitFollower:
	tst	playerFollower
	beq	99$
	clr	R0
	mov	#16., R3
10$:	mov	playerX, followerX(R0)
	mov	playerY, followerY(R0)
	mov	playerSpr, followerSpr(R0)
	inc	R0
	inc	R0
	sob	R3, 10$
99$:	return


; //////////////////////////////////////////////////////////////////////////////
; // Acting
; //////////////////////////////////////////////////////////////////////////////

; process player using items
Acting:
	tst	plActing			; already using item?
	bne	10$
	; start action
	tst	KeyShift
	beq	99$
	clr	KeyShift
	mov	playerItem, R1			; selected item is 0..7
	asl	R1				; to words
	bisb	Items(R1), plActing
	mov	plActing, R0
	asl	R0
	call	@ActingStartTable(R0)
	return
10$:	; process action
	bit	#1, frameCount			; to slow action animation
	bne	99$
	mov	plActing, R0
	asl	R0
	call	@ActingTable(R0)
99$:	return


ActingStartTable:   ; none       light         spade         health 1       ore          key
	.word	AcStartNone, AcStartLight, AcStartSpade, AcStartHealth, AcStartNone, AcStartNone
ActingTable:
	.word	RetFunc, RetFunc, ActingSpade, RetFunc, RetFunc, RetFunc
	; btw, RetFunc = 0 (there is RET code at @#000000)

; nothing to do - clear plActing variable
AcStartNone:
	clr	plActing
	return


AcStartLight:
	clr	plActing			; its immediate
	; check if we can light anything
	mov	#Level, R5
10$:	bit	#^B0010000000000000, (R5)+	; check 'darkened' bit
	bne	20$				; have something can light up
	cmp	R5, #LevelEnd
	blo	10$
	; nothing to light - show message
	mov	#TXTID_CANTLIGHT, DelayedMessage
	return
20$:	mov	#Level, R5
30$:	bic	#^B0010000000000000, (R5)+	; clear 'darkened' bit
	cmp	R5, #LevelEnd
	blo	30$
	call	ConsumeItem			; remove one flashlight
	mov	#SND_EAT, R0			; 'eat' sound
	.ppexe	#CmdSoundPlay	
	call	RedrawFull
	return


AcStartSpade:
	; ask to set hit point (hitpointX must be 0 at this point?)
	mov	#-1, hitpointX
	; can't use in climbing
	cmp	playerState, #PLSCLIMBING
	bne	10$
	clr	plActing
	return
10$:	clr	plActingArg2			; spade acting timer	
	tst	KeyUp				; digging up?
	beq	20$
	mov	#3, plActingArg1		; put direction to 'up'
	return
20$:	tst	KeyDown				; digging down?
	beq	30$
	mov	#1, plActingArg1
	return
30$:	cmp	playerDir, #PLDRIGHT
	bne	40$
	clr	plActingArg1
	return
40$:	mov	#2, plActingArg1
	return


; standard health increase item
AcStartHealth:
 	clr	plActing			; clear acting state, it's immediate
	add	#16., playerLife		; add life
	cmp	playerLife, playerLifeMax	; check for overflow
	ble	90$
	mov	playerLifeMax, playerLife
90$:	; consume item
	call	ConsumeItem			; consume health item
	mov	#SND_EAT, R0			; 'eat' sound
	.ppexe	#CmdSoundPlay
	return


; decrease item count and clear if zero
ConsumeItem:
	mov	playerItem, R1
	asl	R1
	mov	Items(R1), R0
	swab	R0
	decb	R0
	bgt	10$
	clr	R0
10$:	swab	R0
	mov	R0, Items(R1)
	call	UpdateItems
	return


; spade acting
spadeHitsTableX:	.byte	15.+5, 8., -5, 8.
spadeHitsTableY:	.byte	10., 15.+5, 10., -5

ActingSpade:
	; advance animation
	inc	plActingArg2
	cmp	plActingArg2, #3
	blt	99$
	clr	plActing			; stop digging
99$:	return


ProcessHits:
	; check if hitpoint is set
	tst	hitpointX
	ble	99$
	; hitpoint is set - check level tile
	mov	hitpointY, R5
	bic	#^B1111111100001111, R5		; [Y/16]*16
	mov	hitpointX, R0
	bic	#^B1111111100001111, R0		; [X/16]*16
	ash	#-4, R0
	add	R0, R5				; R5=offset in level units
	asl	R5				; R5=offset in words
	; check if hit level breakable tile
	add	#Level, R5
	bit	#^B0000010000000000, (R5)
	beq	90$
	call	SpadeingTile
90$:	; clear hitpoints, used just once
	clr	hitpointX
99$:	return


; 'spadeing' tile, R5 - addr
SpadeingTile:
	tstb	gLevelY				; top level?
	bne	10$
	cmp	R5, #FieldDX*2*5+Level		; 5 top lines on top level can't be digged
	bhis	10$
	return
10$:	bic	#^B0000111111111111, (R5)	; clear tile
	bis	#^B1000000000000000, (R5)	; set as 'need to update'
	; modify this tile and tiles around (place grass|dirt)
	call	DirtifyTile
	; try to change left tile (if not at leftmost already)
	mov	R5, R4
	sub	#Level, R4
	asr	R4
	bic	#^B1111111111110000, R4
	beq	20$
	dec	R5
	dec	R5
	call	DirtifyTile
	inc	R5
	inc	R5
20$:	; try to change right tile (if not at rightmost already)
	mov	R5, R4
	sub	#Level, R4
	asr	R4
	bic	#^B1111111111110000, R4
	inc	R4
	beq	30$
	inc	R5
	inc	R5
	call	DirtifyTile
	dec	R5
	dec	R5
30$:	; try to change upper tile (if not at first line already)
	cmp	R5, #Level+32.
	blo	40$
	sub	#32., R5
	call	DirtifyTile
	add	#32., R5
40$:	; try to change lower tile (if not at bottom line already)
	cmp	R5, #LevelEnd-32.
	bhis	50$
	add	#32., R5
	call	DirtifyTile
	sub	#32., R5
50$:	; change tile in buffer to make a bit of animation
	; get level X,Y from offset
	sub	#Level, R5
	asr	R5
	mov	R5, R1
	bic	#^B1111111111110000, R1
	mov	R5, R2
	bic	#^B1111111100001111, R2
	ash	#-4, R2
	mov	#18., R0
	call	BufTile
	mov	#SND_SPADEING, R0
	.ppexe	#CmdSoundPlay
	mov	#4, R1
	call	AddItem
	call	UpdateItems
	return

; make grass/dirt on tile depending on adjacent
; R5 - level addr
; must set tile # in R0 low byte on return
; 'empty' means any non-solid objects
; out-of-screens are always empty 
DirtifyTile:
	mov	(R5), R0
	cmpb	R0, #10.			; changeable tiles are below #10. by design
	bhis	99$
	; construct bits combination - 001 right, 010 bottom, 100 left
	clrb	R0				; result will be in low-byte R0
	mov	#^B1111111111111100, R2		; bit mask for tile 'weight'
	mov	R5, R4
	sub	#Level, R4
	asr	R4				; R4 = offset in level units
	; check left side
	bic	#^B1111111111110000, R4		; zero nibble means we are at leftmost side, level DX is always 16
	beq	10$				; skip leftmost check
	mov	-2(R5), R1			; it's safe for (0,0) also, there is an extra word for this
	swab	R1
	inc	R1
	bic	R2, R1
	bne	10$
	bis	#^B100, R0			; left is solid
10$:	; check right side
	inc	R4				; for check rightmost side
	bic	#^B1111111111110000, R4		; (15 + 1) & 15 = 0 -> rightmost side
	beq	20$				; skip rightmost check
	mov	2(R5), R1			; it's safe for (15,13) also, there is an extra word for this added after LevelEnd
	swab	R1
	inc	R1
	bic	R2, R1
	bne	20$
	bis	#^B001, R0			; right is solid
20$:	; check bottom 
	cmp	R5, #LevelEnd-32.		; bottom line of level?
	bhis	30$				; don't check it
	mov	32.(R5), R1
	swab	R1
	inc	R1
	bic	R2, R1
	bne	30$
	bis	#^B010, R0
30$:	; make appropriate tile if needed
	tstb	R0
	beq	40$
	inc	R0
	inc	R0
40$:	bis	#100000, R0			; set 'need to update' flag
	mov	R0, (R5)
99$:	return


; //////////////////////////////////////////////////////////////////////////////
; // Items
; //////////////////////////////////////////////////////////////////////////////

; clear items and item counts
ClearItems:
	mov	#Items, R0
	mov	#8., R3
	clr	(R0)+
	sob	R3, .-2
	return


; backup and clear items and set flag that they were backup'ed
BackupItems:
	mov	#Items, R1
	mov	#ItemsBackup, R2
	mov	#8., R3
10$:	mov	(R1), (R2)+
	clr	(R1)+
	sob	R3, 10$
	incb	ItemsWereBkp
	return

; restore items from backup and clear flag that they were backup'ed
RestoreItems:
	tstb	ItemsWereBkp
	beq	99$
	clrb	ItemsWereBkp
	mov	#ItemsBackup, R1
	mov	#Items, R2
	mov	#8., R3
10$:	mov	(R1)+, (R2)+
	sob	R3, 10$
99$:	return


; set items for current episode - do we need that really?
;InitEpisodeItems:
;	call	ClearItems
;	mov	#EpisodeItems-200000, GetA12
;	mov	#Items, R5
;	clr	R4
;20$:	cmp	R4, Episode
;	beq	40$
;30$:	call	GetB12
;	bne	30$
;	inc	R4
;	br	20$
;40$:	call	GetB12
;	beq	99$
;	mov	#400, R1		; item count in hbyte = 1
;	bisb	R0, R1			; item #
;	mov	R1, (R5)+
;	br	40$
;99$:	return


; add item to empty slot (if any), R1 - item ID
AddItem:
	mov	#Items+14., R0		; searching backwards
	mov	#8., R3
	clr	R2
10$:	; check if we already have item and for empty slot
	cmpb	(R0), R1		; do we have it already
	beq	40$			; if yes - increase count
	tst	(R0)			; is it empty slot?
	bne	20$			; no - continue
	mov	R0, R2			; save 'empty' slot addr
20$:	dec	R0
	dec	R0
	sob	R3, 10$
	; have empty slot?
	tst	R2			; have empty slot addr?
	beq	99$			; no - just exit
	mov	R1, (R2)		; put item #
	mov	R2, R0			; continue to set count
40$:	inc	R0
	cmpb	(R0), #99.		; max items is 99.
	bge	99$
	incb	(R0)			; increase item count
	tst	(PC)+			; skip next with C cleared
99$:	sec				; C=1 - item was not added
	return


; find and remove item (ALL), R1 - item ID
; returns removed items count -> R0
RemoveItem:
	mov	#Items, R2
	mov	#8., R3
	clr	R0
10$:	; check if we have item
	cmpb	(R2)+, R1		; is this needed item?
	bne	20$
	bisb	(R2), R0		; put items count to R0
	dec	R2			; and clear both
	clr	(R2)			; item and count
	br	90$
20$:	inc	R2
	sob	R3, 10$
90$:	tst	R0			; to set flags
	return


; find and remove ONE item, R1 - item ID
RemoveOneItem:
	mov	#Items, R2
	mov	#8., R3
10$:	cmpb	(R2)+, R1		; find item by ID
	beq	20$
	inc	R2
	sob	R3, 10$
	return
20$:	decb	(R2)			; decrease item count
	beq	30$
	return
30$:	dec	R2			; no more item - clear it's ID also
	clr	(R2)
	return


; clears items presence vars
ClearItemPresence:
	clrb	LightType		; no flashlight by default
	clrb	HaveKeys		; no keys 
	return


; sets item presence for some items (e.g. flashlight, keys etc)
; R5 - item #
SetItemPresence:
	cmp	R5, #ITEM_LIGHT
	bne	10$
	incb	LightType		; flashlight is present, incb is safe here
10$:	cmp	R5, #ITEM_KEY
	bne	90$
	incb	HaveKeys
90$:	return


; update player items on screen
UpdateItems:
	call	ClearItemPresence	; clears item presence vars
	mov	#Items, varAddr		; item 
	mov	ItemBoxVAddr, varAddr3	; vaddr of item box
10$:	; I haven't 'draw' sprite on arbitrary vaddr proc
	; so - use vbuffers and then copy square
	tstb	@varAddr		; check for 'empty' item
	bne	20$			; to speed up process (just clear)
	;
	; clear item box
	mov	varAddr3, R1		; clear item plane-0 in PPU
	.ppexe	#CmdClrItem
	call	SetVreg			; now clear planes-1,2 in CPU
	mov	R1, (R4)
	mov	#16., R3
	mov	#SCRWID-1, R1
12$:	clr	(R5)
	inc	(R4)
	clr	(R5)
	add	R1, (R4)
	sob	R3, 12$
	br	60$
	;
20$:	; clear vbuffer tile #0
	clr	R0
	clr	R1
	clr	R2
	call	BufTile
	; draw item sprite in buffer at (0,0)
	clr	R5
	bisb	@varAddr, R5
	call	SetItemPresence		; set item presence for some (e.g. flashlight is present and so on)
	clr	R0
	bisb	ItemBaseSpr(R5), R0	; item sprite #
	clr	R1
	clr	R2
	call	BufSprite
	; draw number of items
	mov	varAddr, R5		; addr of [count | item #]
	inc	R5			; R5 = count byte addr
	clr	R0
	bisb	(R5), R0		; R0 = number of items
	cmp	R0, #1			; do not draw 1
	ble	40$
	cmp	R0, #9.			; max number is 9 to draw (items can be more than 9)
	ble	30$
	mov	#9., R0
30$:	asl	R0
	asl	R0
	asl	R0
	add	#SprNumbers45+80., R0
	; put bits
	mov	#BUFWID*10.+1+VBuffer1, R5
	mov	#BUFWID, R2
	bisb	(R0)+, (R5)
	add	R2, R5
	bisb	(R0)+, (R5)
	add	R2, R5
	bisb	(R0)+, (R5)
	add	R2, R5
	bisb	(R0)+, (R5)
	add	R2, R5
	bisb	(R0)+, (R5)
	; now copy square from vbuffers to screen
40$:	mov	varAddr3, R1
	.ppexe	#CmdUpdItem
	call	SetVreg
	mov	R1, (R4)
	mov	#VBuffer1, R1
	mov	#VBuffer2, R2
	mov	#16., R3
50$:	clr	R0
	bisb	(R2)+, R0
	swab	R0
	bisb	(R1)+, R0
	mov	R0, (R5)
	inc	(R4)
	clr	R0
	bisb	(R2)+, R0
	swab	R0
	bisb	(R1)+, R0
	mov	R0, (R5)
	add	#BUFWID-2, R1
	add	#BUFWID-2, R2
	add	#SCRWID-1, (R4)
	sob	R3, 50$
60$:	; advance to next item
	add	#SCRWID*21., varAddr3
	add	#2, varAddr
	cmp	varAddr, #Items+16.
	blo	10$
	; restore vbuffers tile #0 (not always needed but ok)
	clr	R0
	bisb	@#Level, R0
	clr	R1
	clr	R2
	call	BufTile
	return


; test for keyboard pressing [1..8]
ProcItemKeys:
	mov	#8., R1
	mov	#Key8, R0
10$:	tst	(R0)+				; test one key at (R0)
	bne	30$
	sob	R1, 10$
	return
30$:	clr	-(R0)			; clear key state
	dec	R1			; R1 = [0..7] pressed key [1..8]
	cmp	R1, playerItem
	bne	40$			; item already selected
	return
40$:	mov	R1, playerItemNew
SelectNewItem:
	; draw old selected item box in black color
	mov	playerItem, R0
	clr	R1
	call	DrawItemBox
	; draw new selected item box in white color
	mov	playerItemNew, R0
	mov	#177777, R1
	call	DrawItemBox
	mov	playerItemNew, playerItem
	return


; //////////////////////////////////////////////////////////////////////////////
; // Objects
; //////////////////////////////////////////////////////////////////////////////

; Object data: [subtype | type], [arg #1 | arg #0], [? X], [? Y]

; buffer objects (not all objects need drawing, e.g. triggers)
BufferObjects:
	mov	#LevelObj, R0
10$:	mov	(R0), R1
	beq	20$
	cmpb	R1, #TOBJ_ITEM
	beq	50$
	cmpb	R1, #TOBJ_FRIEND
	beq	50$
	cmpb	R1, #TOBJ_ENEMY
	beq	50$
20$:	add	#COBJ_LEN*2, R0
	cmp	R0, #LevelObjEnd
	blo	10$
	return
50$:	mov	R0, -(SP)
	call	BufferObject
	mov	(SP)+, R0
	br	20$


; process level objects routine
ProcessObjects:
	bit	#^B01, FrameCount	; every 2nd frame
	beq	10$
	return
10$:	mov	#LevelObj, Process000+2
Process000:
	mov	#0, R0			; addr of object struct
	mov	(R0), R1		; R1=[subtype | type]
	beq	20$			; have object?
	mov	R1, R2
	clrb	R2
	swab	R2			; R2 = subtype
	bic	#^B1111111100000000, R1	; R1 = type
	asl	R1
	call	@ProcessTable(R1)
20$:	add	#COBJ_LEN*2, Process000+2
	cmp	Process000+2, #LevelObjEnd
	blo	Process000
	return

ProcessTable:
	.word	ProcObjItem, ProcObjFriend, ProcObjEnemy, ProcObjTrig

; process object item - set sprite (TODO: need to set just once?) and check for collisions with player
; R0=addr of obj, R2=subtype=item #
ProcObjItem:
	; test collision with player
	mov	4(R0), R4
	mov	playerX, R5
	call	100$
	bcc	99$
	mov	6(R0), R4
	mov	playerY, R5
	call	100$
	bcc	99$
	; === collided - try add item to inventory ===
	clr	(R0)
	mov	R2, -(SP)	; save item ID
	mov	R2, R1
	call	AddItem
	mov	#SND_ADDITEM, R0
	.ppexe	#CmdSoundPlay
	call	UpdateItems
	; if added for the first time - show description
	mov	(SP)+, R5		; restore item ID
	; check if it was a first time
	mov	#TakenItems-200000, GetA12
	add	R5, GetA12
	call	GetB12			; R0 = item was taken or not
	bne	99$			; was taken already
	; set it as 'was taken already'
	mov	#TakenItems-200000, PutA12
	add	R5, PutA12
	mov	#1, R1
	call	PutB12
	; show message
	mov	#ItemMessage-200000, GetA12
	add	R5, GetA12
	call	GetB12			; R0 = message ID
	incb	MessageNosound		; must show without sound
	mov	R0, DelayedMessage	; will show description with delay a bit
	; ===
99$:	return
; compare coordinates to be inside
100$:
	; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
	add	#12., R4		; 4th pixel from right of obj
	add	#3., R5			; 4th pixel from left of player
	cmp	R5, R4			; player is far right
	bgt	120$
	sub	#9., R4			; 4th pixel from left of obj
	add	#9., R5			; 4th pixel from right of player
	cmp	R5, R4
	blt	120$			; player is far left
	sec
	return
120$:	clc
	return


; friendly object
ProcObjFriend:
	cmp	R2, #TSUB_YANA1		; TODO: proc by table
	beq	10$
	return
10$:	; Yana1 - just turn her to the player direction
	; 32 ->  <- 35
	mov	#32., 2(R0)		; sprite #
	cmp	4(R0), playerX
	blo	20$
	mov	#35., 2(R0)
20$:	return


; trigger object, R0=addr of object, R1=TOBJ_TRIG, R2=trigger subtype
ProcObjTrig:
	; get minimal distance from trigger center to player
	mov	4(R0), R4		; object X
	sub	playerX, R4
	bpl	10$
	neg	R4
10$:	mov	6(R0), R5		; object Y
	sub	playerY, R5
	bpl	20$
	neg	R5
20$:	cmp	R4, R5
	blo	30$
	mov	R4, R5
30$:	; R5 = max distance by X or Y
	; R1 = [arg #1 | arg #0]
	cmp	R5, #12.		; check for distance
	ble	50$
	return
50$:	; if trigger is next episode (trigger subtype)
	cmp	R2, #TRIG_EP_NXT
	bne	60$
	call	NextEpisode
	return	
60$:	; if trigger is message
	cmp	R2, #TRIG_MSG
	bne	70$
	mov	2(R0), R1		; [arg1 | arg0]
	clr	R5
	bisb	R1, R5			; R5 = arg #0 - message #
	clrb	R1
	swab	R1			; R1 = arg #1 - must split it to [type | subtype]
	mov	R1, R4			; save for now
	ash	#3, R4			; upper 3-bits in byte is type
	clrb	R4			; R4 = [type | 0]
	bic	#^B1111111111100000, R1	; get subtype (it's lower 5-bits)
	bis	R4, R1			; now R1 is [type | subtype]
	clr	(R0)			; clear object - message is used just once
	call	EventShowMessage
	return
70$:	; if trigger is approach - then it depends on arg #0
	cmp	R2, #TRIG_APPR
	bne	80$
	clr	R1
	bisb	2(R0), R1		; R1 = event #
	call	RunEvent
	return
80$:
	return


; find object by [type][subtype], if not found - point R0 to playerObj
; R1=[type][subtype]
ObjFindByType:
	tst	R1			; do we need to search at all?
	beq	90$			; no - set on player
	mov	#LevelObj, R0
10$:	cmp	(R0), R1
	beq	99$
	add	#COBJ_LEN*2, R0
	cmp	R0, #LevelObjEnd
	blo	10$
	; not found
90$:	mov	#playerObject, R0
99$:	return


; //////////////////////////////////////////////////////////////////////////////
; // Enemies 
; //////////////////////////////////////////////////////////////////////////////

; object structure for enemies
; [b subtype][b type], [b arg#1][b spr], [w x], [w y]
; X, Y - only low byte used, high bytes are flags

; enemies (spiders, bats etc.)
; R0=addr of object structure, R1=type*2 (TOBJ_ENEMY*2), R2=subtype
ProcObjEnemy:
	mov	R0, R5
	asl	R2
	call	@EnemySubProcTable(R2)
	call	EnemyIntersect
	return

EnemySubProcTable:
	.word	ProcSpider1, ProcSpider2, ProcBat1

; Enemy - Spider 1 
; R5 = obj struct addr, sprites are 24., 25. -> and 26., 27 <-
; try to move in direction of face (forward), try to fall down (have weight=2, normal falling)
ProcSpider1:
	; set sprite animation every for every 2 frames
	bic	#1, 2(R5)
	bis	FrameBit1, 2(R5)
	; Y-movement (falling)
	mov	6(R5), R2			; R2 = Y
	cmp	R2, #FieldDY*16.-16.		; test for out of screen
	bge	10$				; skip falling then
	mov	4(R5), R1			; R1 = X
	add	#4, R2				; Y+4
	call	CheckAvail			; check for avail down
	bcs	10$				; 
	add	#4, 6(R5)			; Y=Y+4
10$:	; X-movement
	mov	4(R5), R1
	mov	6(R5), R2
	bit	#^B0000000000000010, 2(R5)	; check moving direction
	bne	50$
	; move right
	cmp	R1, #FieldDX-2*16.+4		; right screen boundary -12px (to not bite player at the edge)
	bge	18$
	inc	R1
	inc	R1	
	call	CheckAvail
	bcs	18$
	add	#2, 4(R5)
	return
18$:	bis	#^B0000000000000010, 2(R5)	; change direction to 'left'
	return
50$:	; move left
	cmp	R1, #12.			; left screen boundary +12px (spider can't stay on leftmost tile)
	ble	58$
	dec	R1
	dec	R1
	call	CheckAvail
	bcs	58$
	sub	#2, 4(R5)
	return
58$:	bic	#^B0000000000000010, 2(R5)
	return


; spider 2 - try to move up/down
; R5 = obj struct addr, arg#1 - bit 7 (0) - move down
ProcSpider2:
	; set sprite 
	movb	#28., 2(R5)			; 2(R5) = arg#1 | spr#
	add	FrameBit2, 2(R5)
	; X, Y coords
	mov	4(R5), R1
	mov	6(R5), R2
	; Y-movement
	; are we going down? (upper bit of arg#1)
	bit	#^B1000000000000000, 2(R5)	; check moving direction
	bne	50$
	inc	R2				; increase Y and check avail
	inc	R2
	call	CheckAvail
	bcs	20$
	add	#2, 6(R5)			; write Y back
	br	70$
20$:	bis	#^B1000000000000000, 2(R5)	; change direction to 'up'
	br	70$
50$:	dec	R2
	dec	R2
	call	CheckAvail
	bcs	60$
	sub	#2, 6(R5)
	br	70$
60$:	bic	#^B1000000000000000, 2(R5)	; change direction to 'up'
70$:	; need to set tiles with/without web
	; (!) assume spider will never be at very top|bottom|left|right on screen 
	mov	4(R5), R3
	mov	6(R5), R4
	dec	R4			; Y-1
	bic	#^B1111, R4		; R4 = levelY*16
	ash	#-4, R3			; R3 = levelX
	add	R3, R4			; level offset in units
	asl	R4			; level offset in words
	mov	Level(R4), R0		; (!) don't forget use only tile byte
	cmpb	R0, #9.			; modify only 'grassed' tiles
	bhi	72$
	add	#70., Level(R4)
	bis	#^B1000000000000000, Level(R4)
72$:	mov	Level+32.(R4), R0	; remove web from bottom of spider
	cmpb	R0, #70.
	blo	74$
	cmpb	R0, #77.
	bhi	74$
	sub	#70., R0
	mov	R0, Level+32.(R4)
74$:	;
	return


; The Bat enemy, sprites 44.,45. ->  and 46.,47. <-
; arg #1 - bit 7 - move up(0)/down
; R5 = obj struct addr
ProcBat1:
	; set sprite animation every for every 4 frames
	bic	#1, 2(R5)
	bis	FrameBit2, 2(R5)
	; Y-movement
	mov	4(R5), R1
	mov	6(R5), R2
	bit	#^B1000000000000000, 2(R5)
	bne	20$
	; move up
	cmp	R2, #16.
	ble	18$
	sub	#3., R2
	call	CheckAvail
	bcs	18$
	sub	#3, 6(R5)
	br	50$
18$:	bis	#^B1000000000000000, 2(R5)	; set 'move down' flag
	br	50$
20$:	; move down
	cmp	R2, #FieldDY*16.-16.
	bge	28$
	add	#3., R2
	call	CheckAvail
	bcs	28$
	add	#3, 6(R5)
	br	50$
28$:	bic	#^B1000000000000000, 2(R5)
50$:	; X-movement
	mov	4(R5), R1
	mov	6(R5), R2
	bit	#^B0000000000000010, 2(R5)	; check moving direction by sprite #
	bne	60$
	; move right
	cmp	R1, #FieldDX-2*16.+4		; right screen boundary -12px (to not bite player at the edge)
	bge	58$
	add	#3., R1
	call	CheckAvail
	bcs	58$
	add	#3, 4(R5)
	return
58$:	bis	#^B0000000000000010, 2(R5)	; change direction to 'left'
	return
60$:	; move left
	cmp	R1, #12.			; left screen boundary +12px (spider can't stay on leftmost tile)
	ble	68$
	sub	#3., R1
	call	CheckAvail
	bcs	68$
	sub	#3, 4(R5)
	return
68$:	bic	#^B0000000000000010, 2(R5)
	return


; check enemy intersects with player, usually decrease health
; R5=enemy obj
EnemyIntersect:
	mov	4(R5), R1			; R1 = enemy X
	mov	playerX, R2			; R2 = player X
	call	CheckIntersectX
	bcc	99$
	mov	(R5), R4			; [subtype | type]
	clrb	R4
	swab	R4
	movb	EnemiesHeight(R4), R0		; R0 - enemy height-1
	mov	6(R5), R1			; R1 = enemy Y
	mov	playerY, R2			; R2 = player Y
	call	CheckIntersectY
	bcc	99$
	; have intersection, decrease life
	movb	EnemiesAttack(R4), R0
	call	DecreaseLife
99$:	return


; check coordinates X intersect, adjust with some pixels at sides
; R1 = [R1+2..R1+13], R2 = [R2+3..R2+12]
CheckIntersectX:
	add	#2, R1
	add	#12., R2
	cmp	R1, R2
	bhi	90$
	add	#11., R1
	sub	#9., R2
	cmp	R1, R2
	blo	90$
	sec
	return
90$:	clc
	return


; check coordinated Y intersect, adjust enemy Y with R0
CheckIntersectY:
	add	#15., R1
	add	#2., R2
	cmp	R1, R2
	blo	90$
	sub	R0, R1
	add	#13., R2
	cmp	R1, R2
	bhi	90$
	sec
	return
90$:	clc
	return


; //////////////////////////////////////////////////////////////////////////////
; // Events
; //////////////////////////////////////////////////////////////////////////////


; runs game event, R1=event #, R0-object addr
;
RunEvent:
	mov	R0, -(SP)
	; end of episode #0 check
	cmp	R1, #EVC_EPIS0_CHK
	bne	10$
	call	Episode0EndCheck
	bcc	99$
	mov	(SP), R0		; clear trigger object 
	clr	(R0)			; if episode #0 complete
	call	NextEpisode
	br	99$
10$:	;
99$:	tst	(SP)+
	return


; show message for events (or just show it)
; R1=[obj type][obj subtype], R5=msg # (upper bit set = nosound)
EventShowMessage:
	; play default sound?
	tstb	MessageNosound
	bne	10$
	mov	R0, -(SP)
	mov	R5, -(SP)
	mov	#SND_MSGBOX, R0
	.ppexe	#CmdSoundPlay
	mov	(SP)+, R5
	mov	(SP)+, R0
10$:	clrb	MessageNosound
	; try to find such object 
	call	ObjFindByType		; returns R0=obj addr or #playerObj if notfound
	mov	4(R0), R1		; X coord in buffer
	ash	#-3, R1			; make it 8-pix
	add	#FieldX, R1		; adjust with buffer X-position
	mov	6(R0), R2		; Y coord in buffer
	add	#FieldY, R2		; adjust with buffer Y-position
	mov	R5, R0			; R0 - msg #
	.ppexe	#CmdPrintMsg
	clr	KeyAny			; wait for
	tst	KeyAny			; press 'anykey'
	beq	.-4
	call	RedrawFull
	return


; delayed message processing, set or decrease timer and show messahe
ProcessDelayedMsg:
	tst	DelayedMessage		; any message to show?
	bne	10$
	return
10$:	tstb	DelayedMessage+1	; timer was set?
	bne	20$
	movb	#2., DelayedMessage+1	; set default timer to 2 if not
	return
20$:	decb	DelayedMessage+1	; if timer was set - decrease
	beq	30$
	return
30$:	mov	DelayedMessage, R5	; timer went to 0, can use MOV
	clr	R1			; assume coords as player
	call	EventShowMessage	; (!) it will clear DelayedMessage var after RedrawFull
	return


; decrease boulder count and check for episode 0 end
; returns C - flag - episode complete
Episode0EndCheck:
	mov	#ITEM_ORE, R1
	call	RemoveItem		; returns removed count in R0 (and set flags)
	beq	20$			; R0=0? (nothing was removed)
	add	R0, EpisodeVar0
	inc	EpisodeVar1		; allow show message from boss 0
	mov	#SND_REMOVEITEM, R0
	.ppexe	#CmdSoundPlay
	call	UpdateItems
	cmp	EpisodeVar0, #30.	; (30.) enough boulders - end of episode?
	blt	30$			; if no - clear C flag and return
	mov	#TOBJ_FRIEND*256.+TSUB_BOSS, R1
	mov	#TXTID_EP0END, R5
	call	EventShowMessage
	sec
	return
20$:	tst	EpisodeVar1		; was message shown just recently?
	beq	30$
	mov	#TOBJ_FRIEND*256.+TSUB_BOSS, R1
	mov	#TXTID_MSG3, R5
	call	EventShowMessage
	clr	EpisodeVar1
30$:	clc
	return

; //////////////////////////////////////////////////////////////////////////////
; // UTILS, DEBUG, ETC
; //////////////////////////////////////////////////////////////////////////////

@include inc_cpu_utils.mac

; setup regs for work with vram
SetVreg:
	mov	#176640, R4
	mov	#176642, R5
	return

; get byte -> R0 from vaddr and advance it
GetB12:	mov	(PC)+, R0
GetA12:	.word	0			; vram addr rel to 200000
	inc	GetA12
GetR12:	sec
	ror	R0
	bcs	10$
	mov	R0, @#176640
	movb	@#176642, R0
	return
10$:	mov	R0, @#176640
	movb	@#176643, R0
	return

; put R1 -> byte to dest vaddr and advance it
; (!) trashes R2
PutB12:	mov	(PC)+, R2
PutA12:	.word	0			; vram addr rel to 200000
	inc	PutA12
	sec
	ror	R2
	bcs	10$
	mov	R2, @#176640
	movb	R1, @#176642
	return
10$:	mov	R2, @#176640
	movb	R1, @#176643
	return

; vsync wait cycle
VSyncWait:
	clr	R0
VSyncWait1:
	inc	R0			; empty cycles counter
	cmp	VSyncCount1, (PC)+	; check for X vsync
VSyncX:	.word	2			; 1 = 50Hz, 2 = 25Hz
	blo	VSyncWait1
	clr	VSyncCount1
	mov	R0, CpuWaitCount
	.ppexe	#CmdFixWait		; get PPU empty (wait) cycles
	inc	FrameCount
	mov	FrameCount, R0
	clr	R1			; set variables for animations
	ror	R0
	ror	R0
	rol	R1
	mov	R1, FrameBit1
	clr	R1
	ror	R0
	rol	R1
	mov	R1, FrameBit2
	return

; debug info
DebugInfo:
	tstb	DebugMode
	bne	.+4
	return
	bit	#^B1111, FrameCount	; once in 16 frames
	beq	.+4
	return
	mov	#8.*SCRWID+1+VADDR, R1
	mov	KeyCurrent, R0		; pressed/released key
	call	PrintBinaryWord
	mov	#8.*SCRWID+10.+VADDR, R1
	mov	CpuWaitCount, R0	; remaining wait cycles 
	call	PrintOctalWord
	mov	#8.*SCRWID+14.+VADDR, R1
	mov	PpuWaitCount, R0	; remaining PPU wait cycles 
	call	PrintOctalWord
	return

; key K1 - RGB / GRB switch
CheckColors:	
	tst	KeyK1
	bne	10$
	return
10$:	clr	KeyK1
	comb	RgbMode	
	bne	20$
	mov	#^B1101110010011000, R0 ; swap R&G bits
	mov	#^B1111111010111010, R1
	mov	#^B0000000000010000, R2
	mov	#^B0000000000010111, R3
	br	30$
20$:	mov	#^B1011101010011000, R0	; YRGB for 011 010 001 000
	mov	#^B1111111011011100, R1	; YRGB for 111 110 101 100
	mov	#^B0000000000010000, R2 ; no cursor
	mov	#^B0000000000010111, R3 ; 320x288, max luminance
30$:	.ppexe	#CmdUpdPalette		; update palette & resolution
	return

; key STOP - restart all
CheckStop:
	tst	KeyStop
	beq	99$
	clr	KeyStop			; release STOP
	clrb	Pause			; unpause
	clr	CurrentMode		; reset mode
99$:	return

; key combo - debug on|off (and restart)
CheckDebug:
	tst	KeyCombo
	beq	99$
	clr	KeyCombo		; release K2
	clrb	Pause			; unpause
	comb	DebugMode		; debug on|off
	clr	CurrentMode		; reset game
99$:	return

; 'empty' interrupt
RtiAdr:	inc	(PC)+
RtiCnt:	.word	0
	rti

; vsyinc interrupt
VSync:	inc	VSyncCount1		; this one is used in CPU
	inc	VSyncCount2		; this one is used in PPU for music
	rti
	
; //////////////////////////////////////////////////////////////////////////////
; // DATA 
; //////////////////////////////////////////////////////////////////////////////

; TODO: move vars to [0..500] unused interrupts vectors?

CpuWaitCount:	.word	0	; CPU empty cycles counter
FrameCount:	.word	0	; 'frame' counter
FrameBit1:	.word	0	; 0|1 bit #1 of frame counter (for animations)
FrameBit2:	.word	0	; 0|1 bit #2 of frame counter (for animations)

CurrentMode:	.word	0	; game mode (0-reset, 1-menu.. etc)
Episode:	.word	0	; game episode number
EpisodeVar0:	.word	0	; for episode 0 it's boulders count at boss 0
EpisodeVar1:	.word	0

; BYTE-sized variables (!) use with caution ------------------------------------
Pause:		.byte	0	; <>0 - paused
RgbMode:	.byte	0	; RGB/GRB switch
DebugMode:	.byte	0	; debug mode switch
NoSound:	.byte	0	; <>0 - sound procedures will not start
MessageNosound:	.byte	0	; <>0 - next message will be without default sound
TestSoundNum:	.byte	1	; sound test number
EpisodeDream:	.byte	0	; game episode is in dream mode (sprite colors will be only plane 0)
ItemsWereBkp:	.byte	0	; <>0 - items were backed up (for 'dream' episode)
PlayerFlashing:	.byte	0	; <>0 - player are flashing blue (taking damage)
HaveFollower:	.byte	0	; sprite # if player is following by him

glevelX:	.byte	0
glevelY:	.byte	0
glevelNewX:	.byte	0
glevelNewY:	.byte	0

LightType:	.byte	0	; <>0 = flashlight is present in inventory
HaveKeys:	.byte	0	; <>0 - player have key(s)
		.even
; ------------------------------------------------------------------------------

DelayedMessage:	.word	0	; message # to show after delay a bit


; Episode init consts
EListDream:	.byte	0,  1,  0,  1, 0
EListPlayerX:	.byte	200., 128., 200., 4.*16., 14.*16.
EListPlayerY:	.byte	48., 64., 48., 9.*16., 4.*16.
EListPlayerDir:	.byte	1, 1, 1, 1, 1			; do not forget to change next line too!
EListPlayerSpr:	.byte	5., 5., 5., 5., 5.
EListGlevX:	.byte	0., 0., 0., 1., 0.
EListGlevY:	.byte	0., 15., 0., 15., 3.
		; need this for index = -1
		.byte	TXTID_GAMEOVER
EListMsg:	.byte	TXTID_EP0MSG, TXTID_EP1MSG, TXTID_EP2MSG, TXTID_EP3MSG, TXTID_EP4MSG
; episode object changes - 02 episode (glx,gly,objnum, [type|subtype],arg#0,arg#1,coords)
ChgObjE0201:	.byte	0,0, 0, TOBJ_ITEM*32+ITEM_LIGHT, 10., 0, 3*16.+8.	; replace boss with flashlight
		.byte	2,0, 0, 0,0,0,0						; remove 'need light' message
		.byte	-1
ChgObjE0401:	.byte	0,3, 0, 0,0,0,0						; remove tomb next episode object
		.byte	-1
		.even
; tile changing (global offset, new tile #)
ChgTileE0201:	.word	580., TILE_DOOR+1
		.word	-1


; player states
PLSWALKING  = 0
PLSFALLING  = 1
PLSJUMPING  = 2
PLSCLIMBING = 3
PLSDYING    = 4
; player directions
PLDRIGHT = 0
PLDLEFT  = 1
PLDBACK  = 2

jumpTableDY:	.byte	-4, -4, -3, -3, -2, -2, -1, -1, 0, 0
jumpVelocity:	.word	0

SPPAniTable:	.byte	-1, 0, 1, 0	; walking animation sprites addition

drawObject:	.word	0		; for buffer drawing
drawSpr:	.word	0
drawX:		.word	0
drawY:		.word	0

playerSprAdj:	.word	0		; addition to sprite # for player
playerFollower:	.word	0		; sprite # of a follower to player
plCurFolIdx:	.word	0
followerX:	.word	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	; I know about .blkw ^_^
followerY:	.word	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
followerSpr:	.word	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

playerObject:
; --- PLAYER ------------
playerId:	.word	TOBJ_FRIEND	; player's ID, isn't he friend?
playerSpr:	.word	2		; default player spr (walk right)
playerX:	.word	0
playerY:	.word	48.
playerDir:	.word	PLDRIGHT
playerState:	.word	PLSWALKING

playerDX:	.word	0
playerDY:	.word	0
playerAni:	.word	0
playerItem:	.word	1		; currently selected item slot [0..7]
playerItemNew:	.word	1		; item slot to be selected on this frame

playerLife:	.word	0
playerLifeMax:	.word	0
playerLifeCur:	.word	0

plActing:	.word	0		; item number player is using now (it maybe not currently selected)
plActingArg1:	.word	0		; parameter 1 for usage (e.g. direction for spade)
plActingArg2:	.word	0		; parameter 2 for usage (e.g. animation # for spade)
; -----------------------
PlayerObjectEnd:

; player item objects [0..7] (selected with 1..8), low byte - item #, high byte - item count
Items:		.word	0, 0, 0, 0, 0, 0, 0, 0
ItemsBackup:	.word	0, 0, 0, 0, 0, 0, 0, 0	; 'dream' episodes are without items

		;	0    1    2    3    4    5
ItemBaseSpr:	.byte	00., 10., 11., 12., 13., 14.
		.even

hitpointX:	.word	0		; hitting something at this point
hitpointY:	.word	0

; some common-used variables
varX:		.word	0
varY:		.word	0
varDX:		.word	0
varDY:		.word	0
varAddr:	.word	0
varAddr2:	.word	0
varAddr3:	.word	0


; enemies heighs-1 in pixels from bottom
EnemiesHeight:	.byte	8.		; spider 1
		.byte	16.		; spider 2
		.byte	12.		; bat 1
		.even
; enemies attack power
EnemiesAttack:	.byte	8.		; spider 1
		.byte	4.		; spider 2
		.byte	8.		; bat 1
		.even


		; bits: 7 6 5 4 3 2 [1 0]
		; 7 - 'current frame' draw flag, 6 - 'previous frame'
		; 5 - darken tile
		; 4 - hazardous
		; 3 - animated (last 2 bits in tile #)
		; 2 - breakable
		; [1,0] 0 - passable/any, 1 - ladder type, 2 - box type, 3 - solid
.radix 10
		;	0   1   2   3   4   5   6   7   8   9
TilesWeight:	.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 0
		.byte	7,  7,  7,  7,  0,  0,  0,  0,  0,  3	; 10
		.byte	3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 20
		.byte	0,  0,  0,  0,  0,  0,  2,  0,  1,  1	; 30
		.byte	0,  0,  0,  0,  0,  0,  2,  0,  0,  0	; 40
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 50
		.byte	3,  0,  0,  2, 24,  0,  0,  0,  0,  0	; 60
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 70
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 80
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 90
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 100
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 110
		.byte	0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 120
.radix 8		


@include inc_cpu_sprites.mac

LevelObj:	.blkw	COBJ_LEN * 8.			; level objects (max is 8)
LevelObjEnd:

		.word	0				; extra word for (-1,0) coord (needed somewhere in checks)
Level:		.blkw	FieldDX*FieldDY
LevelEnd:
		.word	0				; same extra word for rightmost bottom checks

VBufferSize = FieldDX*FieldDY*CTILE_SIZE		; one buffer size in bytes = DX * DY * tile16 size of one plane
VBuffer1:	.blkb	VBufferSize
VBuffer2:	.blkb	VBufferSize

; ////////////////////////////////////////////////////////////////////////////
; // END CPU MAIN RAM
; ////////////////////////////////////////////////////////////////////////////
END:
; RAM will be cleared after this

; ////////////////////////////////////////////////////////////////////////////
; // VRAM DATA
; ////////////////////////////////////////////////////////////////////////////

.=VDATA*2

@include inc_levels.mac

; episode's item list
;EpisodeItems:	.byte	0		; EP00
;		.byte	0		; EP01
;		.byte	ITEM_SPADE, 0	; EP02
;		.byte	ITEM_SPADE, 0	; EP03
;		.byte	0		; EP04

; First-time taken items's message IDs
ItemMessage:
	.byte	0, TXTID_DESC_LIGHT, TXTID_DESC_SPADE, TXTID_DESC_CHERRY, 
	.byte	0, TXTID_DESC_KEY, 0, 0
	.byte	0, 0, 0, 0, 0, 0, 0, 0
	.byte	0, 0, 0, 0, 0, 0, 0, 0
	.byte	0, 0, 0, 0, 0, 0, 0, 0
; Taken items list (!=0 - was taken once)
TakenItems:	.blkb	32.
TakenItemsEnd:


ENDVram12:
