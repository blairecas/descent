	.title	DESPPU
	.enabl	LC,AMA	; local labels, absolute addr mode
	.list	MEB	; enable macro-extensions binary listing
	.asect
.=0	; from address 0 (!)

; 32-chars symbols length, allow underscore
; macro11.exe -ysl 32 -yus -m ..\..\macro11\sysmac.sml -l _descnt_ppu.lst _descnt_ppu.mac
; custom linker (!) macroses can break it

@include inc_common.mac
@include inc_ppu_header.mac

; ///////////////////////////////////////////////////////////
; // PPU INIT
; ///////////////////////////////////////////////////////////

PPUMain:
	; stack is 540..1000
	mov	#1000, SP
	; clear upper RAM
	call	CLEAUP
	; wait for CPU asking to start phase 3
	mov	#PPUState/2, @#177010
	cmp     #30, @#177014
	bne	.-14

	clr	@#177026		; allow write to all planes (for font output)
	bic	#107, @#177066		; turn off interrupt on CPU-PPU channels	
	; timers
	bic	#^B0000001000000000, @#177054	; disable vsync in PPU
	bis	#^B0000000100000000, @#177054	; enable vsync in CPU
	call	PPTINI			; init pp timer
	bic	#200, @#177716		; turn off sound generator
	; set interrupts
	mov	#INTKeyboard,  @#300	; keyboard interrupt
	bis	#100, @#177700		; allow keyboard interrupts	
	mtps	#0			; allow interrupts

        ; acknowledge start phase 3
	mov	#<PPUState/2>, @#177010	
	mov	#03, @#177014

; //////////////////////////////////////////////////////////////////////////////
; // MAIN PPU CYCLE
; //////////////////////////////////////////////////////////////////////////////

MainCycle:
	call	MusPro
	call	CmdPro
	br	MainCycle

CmdAdr:	.word	0			; command addr/2 in CPU

; process commands from CPU
CmdPro:	mov	#CmdBuffer, @#177010
	tst	@#177014
	bne	10$
	inc	WAIPP0			; 'empty' cycles counter
	return	
10$:	mov	#CmdBuffer+1, CmdAdr	; start of commands address
20$:	cmp	CmdAdr, #CmdBuffer	; out of range (overflow)?
	blos	CmdError
	mov	#177010, R4
	mov	#177014, R5
	; get command
	mov	CmdAdr, (R4)
	mov	(R5), R0
	beq	90$			; end of commands?
	asl	R0			; set procedure addr
	mov	CommandsTable(R0), 00$+2
	; get parameters (R0..R4) and run
	inc	(R4)
	mov	(R5), R0
	inc	(R4)
	mov	(R5), R1
	inc	(R4)
	mov	(R5), R2
	inc	(R4)
	mov	(R5), R3
	inc	(R4)
	mov	(R5), R5
	inc	(R4)
	mov	(R4), CmdAdr
	mov	R5, R4
00$:	call	@#000000		; this addr modified earlier
	br	20$			; next command
90$:	; end of commands
	mov	#CmdBuffer, @#177010	; clear 'ready' word in vram
	clr	@#177014
	return
CmdError:				; TODO: error - do something here
	jmp	Error

; commands table
CommandsTable:
	.word	ERROR			; 00. can't be
	.word	CLEAUP			; 01. cleanup upper RAM
	.word	PALUPD			; 02. set palette, cursor, resolution, luminance (R0,R1 - palette, R2,R3 - cursor, resolution, lumi)
	.word	FXWAIT			; 03. write empty cycles count to CPU
	.word	REQRCN			; 04. write empty INTs count to CPU
	.word	SNDSTA			; 05. start sound
	.word	MUSSTA			; 06. start music
	.word	PrintStr		; 07. print single-height string
	.word	PrintMsg		; 08. print message in box
	.word	ClearVBuffer		; 09. clear buffer
	.word	DrawTile		; 10. draw 16x16 tile to x,y
	.word	DrawTileVaddr		; 11. draw 16x16 tile to vaddr
	.word	DrawTile8Vaddr		; 12. draw 8x8 tile to vaddr
	.word	BufTile			; 13. tile 16x16 to buffer
	.word	BufSprite		; 14. 16x16 sprite with mask to buffer
	.word	Buf2Scr16		; 15. buffer tile 16x16 to screen
	.word	FillScreen		; 16. fill screen plane 0 with R0
	.word	LinesFromR0		; 17. set lines vaddrs starting from R0
	.word	HideScreen		; 18. hides screen (8 lines of bottom is on center)
	.word	DebugString		; 19. show info on bottom of screen
	.word	FadeInScreen		; 20. screen fade in, R0=1..144.
	.word	UpdItem			; 21. update item box with sprite
	
	
; //////////////////////////////////////////////////////////////////////////////
; // Procedures
; //////////////////////////////////////////////////////////////////////////////

; empty interrupt
RTIADR:	inc	(PC)+
RTICNT:	.word	0
	rti

; pp timer ready wait
PptIni:	clr	@#177710
	tst	@#177714
	tst	@#177710
	bne	PPTINI
	return

; 01: clear upper RAM
CleaUp:	mov	#END, R0
	mov	#100000-END/2, R2
	clr	(R0)+
	sob	R2, .-2
	return

; 16: fill screen plane 0 with R0
FillScreen:
	mov	#VADDR, R5
	mov	#SCRWID/2*288., R3
10$:	mov	R0, (R5)+
	sob	R3, 10$
	return
	
; 03: pallete, resolution, cursor, luminance change
PalUpd:	mov	#VLinesBegin, R5
	mov	R0, (R5)+
	mov	R1, (R5)+
	cmp	(R5)+, (R5)+
	mov	R2, (R5)+
	mov	R3, (R5)
	return

; 04: write empty cycles count to CPU
WAIPP0:	.word	0		; PPU wait cycles counter
FXWAIT:	mov	#<PpuWaitCount/2>, @#177010
	mov	WAIPP0, @#177014
	clr	WAIPP0
	return

; 05: request RTICNT to CPU
REQRCN:	mov	#<PpuRtiCount2/2>, @#177010
	mov	RTICNT, @#177014
	return


; //////////////////////////////////////////////////////////////////////////////
; // UTILS 
; //////////////////////////////////////////////////////////////////////////////

@include inc_ppu_utils.mac


; //////////////////////////////////////////////////////////////////////////////
; // sound and music
; //////////////////////////////////////////////////////////////////////////////

MUSCUR:	.word	0 
MUSADR:	.word	0
SNDADR:	.word	0

; music list addrs
MUSTAB:	.word	0, MUS001
; sound list addrs
SNDTAB:	.word	0, SND001

.radix 10

; notes (TODO: need correction a bit, some notes are sounding not that right)
NOTPAD:	.word	1000
	.word	956, 902, 851, 804, 758, 716, 676, 638, 602, 568, 536, 506
	.word	478, 451, 426, 402, 379, 358, 338, 319, 301, 284, 268, 253
	.word	239, 225, 213, 201, 190, 179, 169, 159, 150, 145, 134, 127
	.word	119, 113, 106, 100, 95,  89,  84,  80,  75,  73,  67,  63

; C             D             E      F             G             A             B
; C4-37  C#4-38 D4-39  D#4-40 E4-41  F4-42  F#4-43 G4-44  G#4-45 A4-46  A#4-47 B4-48
; C3-25  C#3-26 D3-27  D#3-28 E3-29  F3-30  F#3-31 G3-32  G#3-33 A3-34  A#3-35 B3-36
; C2-13  C#2-14 D2-15  D#2-16 E2-17  F2-18  F#2-19 G2-20  G#2-21 A2-22  A#2-23 B2-24
; C1-01  C#1-02 D1-03  D#1-04 E1-05  F1-06  F#1-07 G1-08  G#1-09 A1-10  A#1-11 B1-12

.radix 8

; 06: start sound, R0 - sound ID in SNDTAB list
SNDSTA:	mtps	#600
	call	PPTINI
	asl	R0
	mov	SNDTAB(R0), R0
	beq	99$
	mov	(R0)+, R1
	beq	99$
	mov	R0, SNDADR
	mov	R1, @#177712		; load counter
	tst	@#177714
	tst	@#177714
	tst	@#177714
	mov	#SNDINT, @#304		; set sound int
	bis	#^B01000001, @#177710	; allow int, start, timer = 2mks, 500000 ticks per second
99$:	mtps	#0
	return

; 07: start music, R0 - music ID in MUSTAB list
MUSSTA:	mtps	#600			; stop interrupts
	call	PPTINI			; init pp timer
	tst	R0			; 0 - stop music
	bne	10$
	clr	MUSCUR
	mtps	#0
	return
10$:	asl	R0
	mov	MUSTAB(R0), R0		; addr from music table
	movb	(R0), R1		; first note #
	asl	R1
	mov	NOTPAD(R1), @#177712	; initial counter
	mov	R0, MUSCUR		; first note addr
	tst	@#177714
	tst	@#177714
	tst	@#177714
	mov	#MUSIN0, @#304		; set music interrupt
	bis	#^B01000001, @#177710	; allow int, start, timer = 2mks, 500000 ticks per second
	mtps	#0
	return

; mus processor
MUSPRO:	tst	MUSCUR			; current note addr
	bne	1$			; are we are playing?
	return				; no - return
1$:	mov	#<VSyncCount2/2>, @#177010
	cmp	@#177014, #1		; was #2 vsync?
	bhi	2$
	return
2$:	mov	#<VSyncCount2/2>, @#177010
	clr	@#177014
	;	
	mtps	#600			; stop interrupts
	inc	MUSCUR			; advance music note
	movb	@MUSCUR, R1		; note #
	beq	20$			; empty ID - stop playing
	bmi	10$			; empty note
	asl	R1
	mov	NOTPAD(R1), @#177712	; play it
	tst	@#177714
	tst	@#177714
	tst	@#177714
	mov	#200, MUSIN0+2		; set #200 in bis/bic
	mov	#200, MUSIN1+2		; in case we cleared it
	br	99$
10$:	clr	MUSIN0+2		; clear #200 in bis/bic
	clr	MUSIN1+2		; so it will not tick beeper
	br	99$
20$:	call	PPTINI			; init PP timer
	clr	MUSCUR			; music is stopped
99$:	mtps	#0
	return

; PP timer interrupt (for pulse-width modulation)
SNDINT:	mov	R0, -(SP)
	mov	#200, R0
	xor	R0, @#177716
	mov	@SNDADR, R0
	beq	90$
	mov	R0, @#177712
	add	#2, SNDADR
	tst	@#177714
	tst	@#177714
	mov	(SP)+, R0
	rti
90$:	clr	@#177710		; stop timer and ints
	tst	@#177714
	tst	@#177714
	mov	(SP)+, R0
	rti

; PP timer interrupts (for tones)
MUSIN0:	bic	#200, @#177716
	mov	#MUSIN1, @#304
	tst	@#177714
	tst	@#177714
	rti
MUSIN1:	bis	#200, @#177716
	mov	#MUSIN0, @#304
	tst	@#177714
	tst	@#177714
	rti		


; //////////////////////////////////////////////////////////////////////////////
; // KEYBOARD
; //////////////////////////////////////////////////////////////////////////////

; keyboard interrupt
INTKeyboard:
	mov	R0, -(SP)
	mov	@#177702, R0		; (!) read this register ONLY ONCE
	mov	R1, -(SP)
	mov	R2, -(SP)
	mov	R3, -(SP)
	mov	R4, -(SP)
	mov	R5, -(SP)
	mov	#177010, R4
	mov	#177014, R5
	mov	(R4), -(SP)		; save vaddr register 
	; now R0-keycode, (R4)-vaddr, (R5)-vdata
	mov	#KeyCurrent/2, (R4)
	mov	R0, (R5)
	bit	#^B10000000, R0		; key was released?
	bne	50$
	; 0 2 4 6 8 10 == dn,dn,up,up,dn,up ? -> combo is pressed
	; put pressed keys to buffer
	mov	#KeysBuffer, R1
	mov	#KeysBuffer+1, R2
	movb	(R2)+, (R1)+
	movb	(R2)+, (R1)+
	movb	(R2)+, (R1)+
	movb	(R2)+, (R1)+
	movb	(R2)+, (R1)+
	movb	R0, (R1)+
	; check for key buffer combo ^_^
	mov	#6., R3
2$:	cmpb	(R2)+, -(R1)
	bne	4$
	sob	R3, 2$	
	mov	#KeyCombo/2, (R4)	; set 'combo is pressed'
	inc	(R5)
4$:	; -----------------
	; == key pressed ==
	mov	#KeyAny/2, (R4)		; 'anykey' is also pressed
	inc	(R5)
	mov	#KEYSDN, R1
10$:	tst	(R1)
	beq	90$
	cmp	R0, (R1)+
	beq	20$
	add	#4, R1
	br	10$
20$:	; got our key
	mov	(R1)+, (R4)		; set CPU addr
	inc	(R5)			; must be mov #1,(R5) but its ok with inc
	mov	(R1)+, R2
	beq	10$	
	mov	R2, (R4)
	clr	(R5)
	br	10$
50$:	; == key released - R0 = ^B1000xxxx
	bic	#^B1111111111110000, R0
	asl	R0
	mov	KEYSUP+2(R0), R1	; finish addr
	mov	KEYSUP(R0), R0		; start addr
60$:	cmp	R0, R1			; finished?
	bhis	90$
	mov	(R0)+, (R4)		; set CPU addr
	clr	(R5)			; and clear key
	br	60$
	;
90$:	mov	(SP)+, (R4)
	mov	(SP)+, R5
	mov	(SP)+, R4
	mov	(SP)+, R3
	mov	(SP)+, R2
	mov	(SP)+, R1
	mov	(SP)+, R0
	rti

; keys release - clear addrs
KEYSUP:	.word	KUP0000, KUP0001, KUP0010, KUP0011, KUP0100, KUP0101, KUP0110, KUP0111
	.word	KUP1000, KUP1001, KUP1010, KUP1011, KUP1100, KUP1101, KUP1110, KUP1111
	.word	KUP7777
KUP0000:
KUP0001:
KUP0010:
KUP0011:
KUP0100:	.word	KeyStop/2
KUP0101:	.word	KeyShift/2
KUP0110:
KUP0111:
KUP1000:	.word	Key1/2, KeyK1/2
KUP1001:	.word	Key2/2, KeyK2/2
KUP1010:	.word	Key3/2, KeyUst/2
KUP1011:	.word	Key4/2, KeySpace/2, KeyRight/2
KUP1100:	.word	Key5/2, KeyDown/2, KeyUp/2
KUP1101:	.word	Key6/2
KUP1110:	.word	Key7/2, KeyLeft/2
KUP1111:	.word	Key8/2
KUP7777:

; keys press - set 1st addr, clear second
KEYSDN:	.word	^B00000100, KeyStop/2,		0
	.word	^B01101010, KeyUst/2,		0
	.word	^B00011000, Key1/2,		0
	.word	^B00011001, Key2/2,		0
	.word	^B00011010, Key3/2,		0
	.word	^B00001011, Key4/2,		0
	.word	^B00011100, Key5/2,		0
	.word	^B00011101, Key6/2,		0
	.word	^B00001110, Key7/2,		0
	.word	^B00001111, Key8/2,		0
	.word	^B01001011, KeySpace/2,		0
	.word	^B01011100, KeyDown/2,		KeyUp/2
	.word	^B01101100, KeyUp/2,		KeyDown/2
	.word	^B01001110, KeyLeft/2, 		KeyRight/2
	.word	^B01011011, KeyRight/2,		KeyLeft/2
	.word	^B00001000, KeyK1/2,		0
	.word	^B00001001, KeyK2/2,		0
	.word	^B01000101, KeyShift/2,		0
	.word	0
	
KeysBuffer:	.BLKB	6				; last 6 keys
		.BYTE	154, 134, 154, 154, 134, 134	; dn,dn,up,up,dn,up written backwards


; //////////////////////////////////////////////////////////////////////////////
; // PPU ERROR - TODO ?? DEBUG INFO ??
; //////////////////////////////////////////////////////////////////////////////

Error:	mtps	#600			; halt mode
	br	.

; //////////////////////////////////////////////////////////////////////////////
; // DEBUG SCREEN 
; //////////////////////////////////////////////////////////////////////////////

; word to string in decimal xxxxx, R0-word, R5-str addr
DecToStr:
	mov	#5, R3
	add	R3, R5
1$:	mov	R0, R1
	clr	R0
	div	#10., R0
	add	#'0, R1
	movb	R1, -(R5)
	sob	R3, 1$
	return


; put some information at the bottom of screen
DebugString:	
	inc	(PC)+			; set 'already updated'
	.word	177777			; if string is already updated - then skip
	bne	99$
	; R0 = free CPU bytes
	mov	#TxtDebug01+15., R5
	call	DecToStr
	; R4 = free VRAM12 bytes
	mov	R4, R0
	mov	#TxtDebug03+11., R5
	call	DecToStr
	; put free PPU bytes
	mov	#100000-END, R0
	mov	#TxtDebug01+27., R5
	call	DecToStr
	; put free VRAM0 bytes
	mov	#CmdBuffer-ENDVram0, R0
	mov	#TxtDebug03+23., R5
	call	DecToStr
	; check for real 1801VM2
	clr	R1
	mov	(PC), R0
	inc	R1
	br	10$
10$:	cmp	R1, #1
	beq	99$
	mov	#TxtDebug02, R1		; copy 9 bytes of text
	mov	#TxtDebug01+35., R2
	mov	#9., R3
	movb	(R1)+, (R2)+
	sob	R3, .-2
99$:	; out free CPU/PPU RAM string
	mov	#5., R1
	mov	#270., R2
	mov	#TxtDebug01, R0
	call	PrintStr
	; out free video RAM string
	mov	#8., R1
	mov	#279., R2
	mov	#TxtDebug03, R0
	call	PrintStr
	return
	
	

; //////////////////////////////////////////////////////////////////////////////
; // PPU DATA SECTION //////////////////////////////////////////////////////////
; //////////////////////////////////////////////////////////////////////////////

; // SOUND & MUSIC /////////////////////////////////////////////////////////////

.radix 10

; C             D             E      F             G             A             B
; C4-37 C#4-38  D4-39 D#4-40  E4-41  F4-42 F#4-43  G4-44 G#4-45  A4-46 A#4-47  B4-48
; C3-25 C#3-26  D3-27 D#3-28  E3-29  F3-30 F#3-31  G3-32 G#3-33  A3-34 A#3-35  B3-36
; C2-13 C#2-14  D2-15 D#2-16  E2-17  F2-18 F#2-19  G2-20 G#2-21  A2-22 A#2-23  B2-24
; C1-01 C#1-02  D1-03 D#1-04  E1-05  F1-06 F#1-07  G1-08 G#1-09  A1-10 A#1-11  B1-12

; music #1
MUS001:
	.byte	13, 16, 20
	.byte	13, 16, 20

	.byte	13, 16, 20
	.byte	13, 16, 20

	.byte	08, 13, 16
	.byte	08, 13, -1

	.byte	10, 13, -1
	.byte	12, 15, -1
	
	.byte	13, 16, -1
	.byte	12, 15, -1
	
	.byte	13, 16, -1
	.byte	15, 12, -1
	
	.byte	16, 13, -1
	.byte	15, 12, -1
	
	.byte	16, 13, -1
	.byte	18, 09, -1

	.byte	12, 15, 20
	.byte	12, 15, 20
	
	.byte	12, 15, 20
	.byte	12, 15, 20
	
	.byte	08, 12, 15
	.byte	08, 12, -1

	.byte	10, 13, -1
	.byte	12, 15, -1
	
	.byte	13, 16, -1
	.byte	12, 15, -1
	
	.byte	13, 16, -1
	.byte	15, 18, -1
	
	.byte	16, 08, -1
	.byte	15, 09, -1
	
	.byte	16, 08, -1
	.byte	18, 09, -1

	.byte	13, 20, -1
	.byte	13, 20, -1

	.byte	25, -1, -1
	.byte	25, -1, -1

	.byte	25, -1, -1
	.byte	25, -1, -1

	.byte	25, -1, -1
	.byte	25, -1, -1

	.byte	25, -1, -1
	.byte	25, -1, -1

	.byte	18, -1, -1
	.byte	18, -1, -1

	.byte	18, -1, -1
	.byte	18, -1, -1

	.byte	18, -1, -1
	.byte	18, -1, -1

	.byte	16, -1, -1
	.byte	16, -1, -1

	.byte	20, -1, -1
	.byte	20, -1, -1

	.byte	20, -1, -1
	.byte	20, -1, -1

	.byte	20, -1, -1
	.byte	20, -1, -1

	.byte	22, -1, -1
	.byte	22, -1, -1

	.byte	15, -1, -1
	.byte	15, -1, -1

	.byte	15, -1, -1
	.byte	15, -1, -1

	.byte	13, -1, -1
	.byte	13, -1, -1

	.byte	12, -1, -1
	.byte	12, -1, -1


;	.BYTE	01, 10, 13
;	.BYTE	01, 10, 13
;	.BYTE	03, 09, 12
;	.BYTE	03, 09, 12

;	.BYTE	01, 05, 10
;	.BYTE	01, 05, 10
;	.BYTE	03, 09, 12
;	.BYTE	03, 09, 12

;	.BYTE	01, 10, 13
;	.BYTE	01, 10, 13
;	.BYTE	01, 10, 13
;	.BYTE	01, 10, 13
		
	.BYTE	0
	.EVEN

; boom
SND001:	.word	859, 506, 511, 507, 1527, 510, 508, 509, 509, 1526, 510, 1017, 510, 2033, 1021
	.word	1015, 1529, 2002, 495, 491, 1973, 494, 984, 495, 984, 988, 968, 480, 475, 1909, 1431
	.word	0


.radix 8


; // SPRITES ////////////////////////////////////////////////////////////////////

@include inc_ppu_sprites.mac	

TxtTable:	.word	TXT_Menu00, TXT_Menu01, TXT_Menu02, TXT_Menu03, TXT_Menu04, TXT_MENU05, TXT_Menu06, TXT_Test1, TXT_Pre_Intro, TXT_Msg1
		.word	TXT_Msg2


TxtDebug01:	.asciz	<1>" Свободно ЦП:"<2>"00000"<1>", ПП:"<2>"00000"<1>", эмуляция"
TxtDebug02:	.asciz	<3>"1801вм2"
TxtDebug03:	.asciz	<1>"Видео 12:"<2>"00000"<1>", В0:"<2>"00000"

		.even

VBufferSize = FieldDX*32.*FieldDY
VBuffer0:	.blkb	VBufferSize

END:
; RAM will be cleared after this

; //////////////////////////////////////////////////////////////////////////////
; // VRAM 
; //////////////////////////////////////////////////////////////////////////////

.=VDATA

TXT_Menu00:	.asciz	<7>"<>'`"<5>" - "<6>"Движение"
TXT_Menu01:	.asciz	<7>"1..8"<5>" - "<6>"Предмет"
TXT_Menu02:	.asciz	<7>" РЕГ"<5>" - "<6>"Использовать"
TXT_Menu03:	.asciz	<7>"  К1"<5>" - "<6>"Палитра "<4>"R"<2>"G"<1>"B"<6>"/"<2>"G"<4>"R"<1>"B"
TXT_Menu04:	.asciz	<7>" УСТ"<5>" - "<6>"Пауза"
TXT_Menu05:	.asciz	<7>"СТОП"<5>" - "<6>"Сброс игры"
TXT_Menu06:	.asciz	<6>" НАЖМИТЕ "<7>"ПРОБЕЛ"

TXT_Pre_Intro:	.asciz	<7>"═╡ Ночная смена ╞═"

TXT_Test1:	.ascii	<1>"Один"<12>
		.ascii	<2>"Два"<12>
		.ascii	<3>"Три"<12>
		.ascii	<4>"Четыре"<0>

TXT_Msg1:	.asciz	<2>"Твоя смена. Лопата в шахте"<12><2>"Накопанное сложишь в этот"<12><2>"большой ящик"
TXT_Msg2:	.asciz	<6>"Лопатой можно копать"<12><6>"..или бить врага"

ENDVram0:
